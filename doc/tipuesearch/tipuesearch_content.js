var tipuesearch = {"pages":[{"title":" Quantum transport simulator ","text":"Quantum transport simulator Developer Info Jiang Cao","tags":"home","loc":"index.html"},{"title":"type_matrix_complex – Quantum transport simulator ","text":"type, public :: type_matrix_complex Contents Variables m size Source Code type_matrix_complex Components Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: m (:,:) complex matrix integer, public :: size (2) matrix size Source Code type type_matrix_complex complex ( 8 ), allocatable :: m (:, :) !! complex matrix integer :: size ( 2 ) !! matrix size end type type_matrix_complex","tags":"","loc":"type/type_matrix_complex.html"},{"title":"deviceHam_load_COOmatrix – Quantum transport simulator","text":"public  subroutine deviceHam_load_COOmatrix(fname, H, nnz, nm, row, col, use0index, complex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name complex(kind=dp), intent(out), allocatable, dimension(:) :: H integer, intent(out) :: nnz integer, intent(out) :: nm integer, intent(out), allocatable, dimension(:) :: row integer, intent(out), allocatable, dimension(:) :: col logical, intent(in), optional :: use0index logical, intent(in), optional :: complex Contents Source Code deviceHam_load_COOmatrix Source Code subroutine deviceHam_load_COOmatrix ( fname , H , nnz , nm , row , col , use0index , complex ) character ( len =* ), intent ( in ) :: fname !! input text file name complex ( dp ), allocatable , intent ( out ), dimension (:) :: H integer , allocatable , intent ( out ), dimension (:) :: row , col integer , intent ( out ) :: nnz integer , intent ( out ) :: nm logical , intent ( in ), optional :: use0index , complex logical :: l0index real ( dp ) :: re , im integer :: handle , io integer :: M , NL , i , j , k handle = 101 l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) M = - HUGE ( 1 ) NL = 0 ! Read through the file first to know the number of lines do read ( handle , * , IOSTAT = IO ) i , j , re if ( IO < 0 ) exit if ( max ( i , j ) > M ) M = max ( i , j ) NL = NL + 1 end do print '(\"Number of nonzeros = \",i18)' , NL allocate ( H ( NL )) allocate ( row ( NL )) allocate ( col ( NL )) H = 0.0d0 nnz = NL nm = M ! Read again the file for the matrix rewind handle im = 0.0d0 do k = 1 , NL if (( present ( complex )) . and . complex ) then read ( handle , * ) i , j , re , im else read ( handle , * ) i , j , re end if if ( l0index ) then i = i + 1 j = j + 1 end if row ( k ) = i col ( k ) = j H ( k ) = dcmplx ( re , im ) end do close ( handle ) end subroutine deviceHam_load_COOmatrix","tags":"","loc":"proc/deviceham_load_coomatrix.html"},{"title":"deviceHam_build_blocks – Quantum transport simulator","text":"public  subroutine deviceHam_build_blocks(H, row, col, Hii, H1i, Slices, ext_left, ext_right, num_slice) Uses matrix_c proc~~deviceham_build_blocks~~UsesGraph proc~deviceham_build_blocks deviceHam_mod::deviceHam_build_blocks module~matrix_c matrix_c proc~deviceham_build_blocks->module~matrix_c Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: H Hamiltonian matrix value in COO integer, intent(in), dimension(:) :: row Hamiltonian matrix index in COO integer, intent(in), dimension(:) :: col Hamiltonian matrix index in COO type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: Hii Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: H1i Hamiltonian blocks integer, intent(in), dimension(:, :) :: Slices slicing information , refer to graph_partition integer, intent(in) :: ext_left extension on left/right side, number of slices in the central part integer, intent(in) :: ext_right extension on left/right side, number of slices in the central part integer, intent(in) :: num_slice extension on left/right side, number of slices in the central part Contents Source Code deviceHam_build_blocks Source Code subroutine deviceHam_build_blocks ( H , row , col , Hii , H1i , Slices , ext_left , ext_right , num_slice ) use matrix_c , only : type_matrix_complex complex ( dp ), intent ( in ), dimension (:) :: H !! Hamiltonian matrix value in COO integer , intent ( in ), dimension (:) :: row , col !! Hamiltonian matrix index in COO integer , intent ( in ) :: ext_left , ext_right , num_slice !! extension on left/right side, number of slices in the central part type ( type_matrix_complex ), dimension (:), intent ( inout ), allocatable :: Hii , H1i !! Hamiltonian blocks integer , intent ( in ), dimension (:, :) :: Slices !! slicing information , refer to [[graph_partition]] ! ---- integer :: nx allocate ( Hii ( nx )) allocate ( H1i ( nx - 1 )) end subroutine deviceHam_build_blocks","tags":"","loc":"proc/deviceham_build_blocks.html"},{"title":"getPointsInAllSlices – Quantum transport simulator","text":"public  function getPointsInAllSlices(S) result(v) Function returns the points in all the slices Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information Return Value integer, (sum(S(1,:))-size(S,2)) Contents Source Code getPointsInAllSlices Source Code function getPointsInAllSlices ( S ) result ( v ) !! Function returns the points in all the slices implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer :: v ( sum ( S ( 1 , :)) - size ( S , 2 )) integer :: i , n n = 0 do i = 1 , size ( S , 2 ) v ( n + 1 : n + S ( 1 , i ) - 1 ) = S ( 2 : S ( 1 , i ), i ) n = n + S ( 1 , i ) - 1 end do end function getPointsInAllSlices","tags":"","loc":"proc/getpointsinallslices.html"},{"title":"getPointsInSlice – Quantum transport simulator","text":"public  function getPointsInSlice(S, i) result(v) Function returns the points in a slice number i Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information integer, intent(in) :: i Slice number Return Value integer, (S(1,i)-1) Contents Source Code getPointsInSlice Source Code function getPointsInSlice ( S , i ) result ( v ) !! Function returns the points in a slice number `i` implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer , intent ( in ) :: i !! Slice number integer :: v ( S ( 1 , i ) - 1 ) v (:) = S ( 2 : S ( 1 , i ), i ) end function getPointsInSlice","tags":"","loc":"proc/getpointsinslice.html"},{"title":"testSlicing – Quantum transport simulator","text":"public  function testSlicing(g, S) result(b) Function tests if a slicing from subroutine slice of the graph is consistent by\nlooking at the neighbors of all the points in each slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: S (:,:) Slices, 2nd index is the Slice number Return Value integer Test result Contents Source Code testSlicing Source Code function testSlicing ( g , S ) result ( b ) !! Function tests if a slicing from subroutine [[slice]]  of the graph is consistent by !! looking at the neighbors of all the points in each slice. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer :: b !! Test result integer , intent ( in ) :: S (:, :) !! Slices, 2nd index is the Slice number integer :: L ( size ( g , 2 )) !! Slice number of points integer :: i , k , j , err L = - 1 L = SliceNum ( S ) IF ( ANY ( L == - 1 )) then b = - 1 ! Not all points belong to a slice return end if do i = 1 , size ( S , 2 ) ! Loop over the slices do j = 2 , S ( 1 , i ) ! Loop over the points in one slice do k = 2 , g ( 1 , S ( j , i )) ! Loop over all its neighbor points if ( abs ( L ( g ( k , S ( j , i ))) - i ) > 1 ) then b = i ! It connects to a points too far print '(4I18)' , L ( g ( k , S ( j , i ))), g ( k , S ( j , i )), i , S ( j , i ) return end if end do end do end do b = 0 end Function testSlicing","tags":"","loc":"proc/testslicing.html"},{"title":"SaveSlicesTxt – Quantum transport simulator","text":"public  subroutine SaveSlicesTxt(handle, S, X, Y, Z) Procedure saves the slice information into a text file Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle file unit number integer, intent(in) :: S (:,:) Slices information real(kind=dp), intent(in), optional :: X (:) real(kind=dp), intent(in), optional :: Y (:) real(kind=dp), intent(in), optional :: Z (:) Contents Source Code SaveSlicesTxt Source Code subroutine SaveSlicesTxt ( handle , S , X , Y , Z ) !! Procedure saves the slice information into a text file implicit none integer , intent ( in ) :: handle !! file unit number integer , intent ( in ) :: S (:, :) !! Slices information real ( dp ), intent ( in ), optional :: X (:) real ( dp ), intent ( in ), optional :: Y (:) real ( dp ), intent ( in ), optional :: Z (:) integer :: i , j write ( handle , * ) '# number of points in each slice' write ( handle , '(8I10)' ) S ( 1 , :) - 1 ! number of points in each slice if ( present ( X ) . and . present ( Y ) . and . present ( Z )) then write ( handle , * ) '#     X         Y         Z       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(3E15.5,I10)' ) X ( S ( j , i )), Y ( S ( j , i )), Z ( S ( j , i )), i end do end do else write ( handle , * ) '#    Point#       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(2I10)' ) S ( j , i ), i end do end do end if end subroutine SaveSlicesTxt","tags":"","loc":"proc/saveslicestxt.html"},{"title":"AddEdge – Quantum transport simulator","text":"public  subroutine AddEdge(g, ij) Subroutine update the graph data (g) by adding an edge from node-i to node-j.\nThe memory space for (g) is already allocated before calling this procedure Arguments Type Intent Optional Attributes Name integer, intent(out) :: g (:,:) integer, intent(in) :: ij (2) Called by proc~~addedge~~CalledByGraph proc~addedge graph_partition::AddEdge proc~readgraphfromtext graph_partition::ReadGraphFromText proc~readgraphfromtext->proc~addedge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code AddEdge Source Code subroutine AddEdge ( g , ij ) !! Subroutine update the graph data (g) by adding an edge from node-i to node-j. !! The memory space for (g) is already allocated before calling this procedure implicit none integer , intent ( out ) :: g (:, :) integer , intent ( in ) :: ij ( 2 ) ! Find if this Edge is already present in the graph, avoiding duplicates if ( ANY ( g ( 2 : g ( 1 , ij ( 1 )), ij ( 1 )) == ij ( 2 ))) then return else g ( 1 , ij ( 1 )) = g ( 1 , ij ( 1 )) + 1 g ( 1 , ij ( 2 )) = g ( 1 , ij ( 2 )) + 1 g ( g ( 1 , ij ( 2 )), ij ( 2 )) = ij ( 1 ) g ( g ( 1 , ij ( 1 )), ij ( 1 )) = ij ( 2 ) end if end subroutine AddEdge","tags":"","loc":"proc/addedge.html"},{"title":"ReadEdgeFromText – Quantum transport simulator","text":"public  subroutine ReadEdgeFromText(fname, E, use0index) Subroutine for reading the edge data from an ASCII text file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: E (:) Edge index logical, intent(in), optional :: use0index Contents Source Code ReadEdgeFromText Source Code subroutine ReadEdgeFromText ( fname , E , use0index ) !! Subroutine for reading the edge data from an ASCII text file. implicit none integer , allocatable , intent ( out ) :: E (:) !! Edge index character ( len =* ), intent ( in ) :: fname !! input text file name logical , intent ( in ), optional :: use0index integer :: NPT , i integer , parameter :: handle = 677 logical :: l0index l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) read ( handle , * ) NPT ! number of points allocate ( E ( NPT )) read ( handle , * ) E (:) if ( l0index ) E (:) = E (:) + 1 !do i=1,NPT !        read(handle,*) E(i) !        if (l0index) then !          E(i) = E(i)+1 !        endif !enddo close ( handle ) end subroutine ReadEdgeFromText","tags":"","loc":"proc/readedgefromtext.html"},{"title":"ReadGraphFromText – Quantum transport simulator","text":"public  subroutine ReadGraphFromText(fname, g, threshold, use0index) Subroutine for reading in the graph data from an ASCII text file. Note The graph connectivity table is stored in a 2D integer array g(:,:) which\nis allocated inside this subroutine, so remember to deallocate it outside.\nThe 2nd index of g(:,:) refers to the point ID and 'g(1,:)-1' is the number of connections\nof the point. The text file should contain 2 columns of integers which are the point\nIDs of 2 connected points in the graph. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: g (:,:) Graph connectivity table. real(kind=8), intent(in), optional :: threshold logical, intent(in), optional :: use0index Calls proc~~readgraphfromtext~~CallsGraph proc~readgraphfromtext graph_partition::ReadGraphFromText proc~addedge graph_partition::AddEdge proc~readgraphfromtext->proc~addedge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code ReadGraphFromText Source Code subroutine ReadGraphFromText ( fname , g , threshold , use0index ) !! Subroutine for reading in the graph data from an ASCII text file. !! !! @note The graph connectivity table is stored in a 2D integer array `g(:,:)` which !! is allocated inside this subroutine, so remember to deallocate it outside. !! The 2nd index of `g(:,:)` refers to the point ID and 'g(1,:)-1' is the number of connections !! of the point. The text file should contain 2 columns of integers which are the point !! IDs of 2 connected points in the graph. !! implicit none integer , allocatable , intent ( out ) :: g (:, :) !! Graph connectivity table. character ( len =* ), intent ( in ) :: fname !! input text file name real ( 8 ), intent ( in ), optional :: threshold logical , intent ( in ), optional :: use0index integer , allocatable :: gn (:) !! Temporary array for sizing the Graph Table integer :: i , j , k !! Looping variables integer :: NL !! Number of lines in the text file integer :: IO !! IO state during reading integer :: M !! Number of points in the graph integer :: NC integer , parameter :: handle = 675 logical :: l0index real ( 8 ) :: weight l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) M = - HUGE ( 1 ) NL = 0 ! Read through the file first to know the number of points in the graph do read ( handle , * , IOSTAT = IO ) i , j if ( l0index ) then i = i + 1 j = j + 1 end if if ( IO < 0 ) exit if ( max ( i , j ) > M ) M = max ( i , j ) NL = NL + 1 end do print '(\"Number of Points = \",i18)' , M allocate ( gn ( M )) gn = 0 ! Read again the file to know about the size of the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if else gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if end do NC = maxval ( gn ) print '(\"Max Number of Connections = \",i18)' , NC allocate ( g ( NC + 1 , M )) g (:, :) = 0 g ( 1 , :) = 1 deallocate ( gn ) ! Read last time the file for the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( i . ne . j ) then if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then call AddEdge ( g , ( / i , j / )) end if else call AddEdge ( g , ( / i , j / )) end if end if end do close ( handle ) end subroutine ReadGraphFromText","tags":"","loc":"proc/readgraphfromtext.html"},{"title":"SaveTxtGraph – Quantum transport simulator","text":"public  subroutine SaveTxtGraph(handle, g) Subroutine for saving the graph data into an ASCII text file. Note The 1st column is the point ID, and the following columns are the connecting points' ID. Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle Unit number of the input text file integer, intent(in) :: g (:,:) Graph connectivity table. Contents Source Code SaveTxtGraph Source Code subroutine SaveTxtGraph ( handle , g ) !! Subroutine for saving the graph data into an ASCII text file. !! !! @note The 1st column is the point ID, and the following columns are the connecting points' ID. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ), optional :: handle !! Unit number of the input text file character ( len = 1024 ) :: str !! String for FORMAT writing integer :: i !! Looping variable write ( str , \"(I10)\" ) size ( g , 1 ) + 1 if ( present ( handle )) then do i = 1 , size ( g , 2 ) write ( handle , '(' // trim ( adjustl ( str )) // 'i10)' ) i , g ( 2 : g ( 1 , i ), i ) end do else do i = 1 , size ( g , 2 ) print '(' // trim ( adjustl ( str )) // 'i10)' , i , g ( 2 : g ( 1 , i ), i ) end do end if end subroutine SaveTxtGraph","tags":"","loc":"proc/savetxtgraph.html"},{"title":"slice – Quantum transport simulator","text":"public interface slice Contents Module Procedures slice_1contact slice_2contacts Module Procedures private  subroutine slice_1contact(g, E, S) Procedure returns the slices of the graph going from 1 edge. BFS algorithm is used to\nassign a distance to the edge for each point, then the slice number = distance. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E (:) Left Edge points' IDs integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number private recursive subroutine slice_2contacts(g, E1, E2, NMAX, S) Function returns the slices of the graph. The problem is solved in a divide-and-conquer\nmanner, using recursive bisection method described in [Journal of Computational Physics 228 (2009) 8548–8565]. Compute the left/right distance of points to left/right edges, by calling [[dist]] Divide the graph into 2 'balanced' parts, based on if the right distance is larger than the left distance Find the connections between 2 parts, and define a new set of edges Recursion, Slice seperately the 2 parts Combine the results Stop condition: either the 2 edges touch each other, or the number of points in the remaining part gets\nsmall enough. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E1 (:) Left Edge points' IDs integer, intent(in) :: E2 (:) RightEdge points' IDs integer, intent(in) :: NMAX Maximum number of points in a single slice integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number","tags":"","loc":"interface/slice.html"},{"title":"rgf_variableblock_backward – Quantum transport simulator","text":"public  subroutine rgf_variableblock_backward(En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) Uses static matrix_c proc~~rgf_variableblock_backward~~UsesGraph proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward module~matrix_c matrix_c proc~rgf_variableblock_backward->module~matrix_c module~static static proc~rgf_variableblock_backward->module~static Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. ! H00 = H(i,i) + Sigma_ph(i) * S(i,i)\n! Sigma_R = H(i,i+1) * G00 * H(i+1,i)\n! Gl(i) = [En S(i,i) - H00 - Sigma_R]&#94;-1\n! H00 = H(i,i) + Sigma_ph(i) * S(i,i)\n! Gl(i) = [En S(i,i) - H00 - H(i,i+1) * Gl(i+1) * H(i+1,i)]&#94;-1\n! Gln(i) = Gl(i) * [Sigma_ph<(i) S(i,i) + H(i,i+1) Gln(i+1) H(i+1,i)] * Gl(i)'\n! Sigma&#94;< = Sigma_11&#94;< + Sigma_ph&#94;< + Sigma_s&#94;<\n! G&#94;< = G * Sigma&#94;< * G'\n! A = G<(i-1) * H(i-1,i) * Gl(i)' + G(i-1) * H(i-1,i) * Gln(i)\n! B = H(i,i-1) * A\n! Jdens(i) = -2 * re(B)\n! GN0 = Gl(i) * H(i,i-1) * G(i-1)\n! G(i) = Gl(i) + GN0 * H(i-1,i) * Gl(i)\n! G<(i) = Gln(i) + Gl(i) * H(i,i-1) * G<(i-1) * H(i-1,i) Gl(i)'\n! G<(i) = G<(i) + GNO * H(i-1,i) * Gln(i)\n! G<(i) = G<(i) + Gln(i) * H(i,i-1) * GN0\n! G>(i) = G<(i) + (G(i) - G(i)') Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (:) type( type_matrix_complex ), intent(in) :: H1i (:) type( type_matrix_complex ), intent(in) :: Sii (:) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (:) type( type_matrix_complex ), intent(in) :: sigma_r_ph (:) type( type_matrix_complex ), intent(inout) :: G_r (:) type( type_matrix_complex ), intent(inout) :: G_lesser (:) type( type_matrix_complex ), intent(inout) :: G_greater (:) type( type_matrix_complex ), intent(inout) :: Jdens (:) type( type_matrix_complex ), intent(inout) :: Gl (:) type( type_matrix_complex ), intent(inout) :: Gln (:) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre Calls proc~~rgf_variableblock_backward~~CallsGraph proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward interface~trace matrix_c::trace proc~rgf_variableblock_backward->interface~trace proc~array_inverse matrix_c::array_inverse proc~rgf_variableblock_backward->proc~array_inverse proc~mul_c matrix_c::MUL_C proc~rgf_variableblock_backward->proc~mul_c proc~trimul_c matrix_c::triMUL_C proc~rgf_variableblock_backward->proc~trimul_c proc~array_trace matrix_c::array_trace interface~trace->proc~array_trace proc~matrix_trace matrix_c::matrix_trace interface~trace->proc~matrix_trace zgetrf zgetrf proc~array_inverse->zgetrf zgetri zgetri proc~array_inverse->zgetri zgemm zgemm proc~mul_c->zgemm proc~trimul_c->proc~mul_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code rgf_variableblock_backward Source Code subroutine rgf_variableblock_backward ( En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) use matrix_c , only : type_matrix_complex , MUL_C , triMUL_C , inv => array_inverse , trace use static type ( type_matrix_complex ), intent ( in ) :: Hii (:), H1i (:), Sii (:), sigma_lesser_ph (:), sigma_r_ph (:) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) type ( type_matrix_complex ), intent ( inout ) :: G_greater (:), G_lesser (:), G_r (:), Jdens (:), Gl (:), Gln (:) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: nx , M , ii , jj complex ( dp ) :: z real ( dp ) :: tim complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) nx = size ( Hii ) ! <- lenght of the device z = dcmplx ( En , 0.0d0 ) ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmar ( M , M )) allocate ( sig ( M , M )) ! !!! H00 = H(i,i) + Sigma_ph(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B call sancho ( M , En , Sii ( ii )% m , H00 , H1i ( ii + 1 )% m , G00 , GBB ) !$omp critical open ( unit = 10 , file = 'sancho_g00.dat' , position = 'append' ) write ( 10 , * ) En , 2 , - aimag ( trace ( G00 )) close ( 10 ) open ( unit = 10 , file = 'sancho_gbb.dat' , position = 'append' ) write ( 10 , * ) En , 2 , - aimag ( trace ( Gbb )) close ( 10 ) !$omp end critical ! !!! Sigma_R = H(i,i+1) * G00 * H(i+1,i) !!! Gl(i) = [En*S(i,i) - H00 - Sigma_R]&#94;-1 call triMUL_c ( H1i ( ii + 1 )% m , G00 , H1i ( ii + 1 )% m , sigmar , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmar Gl ( ii )% m = inv ( B ) ! ! Gln(i) = Gl(i) * [Sigma_ph<(i)*S(i,i) + (-(Sigma_R - Sigma_R')*ferm(..))] * Gl(i)' call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig ) ! allocate ( A ( M , M )) ! inside device r -> l do ii = nx - 1 , 2 , - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !!! H00 = H(i,i) + Sigma_ph(i) * S(i,i) !!! Gl(i) = [En*S(i,i) - H00 - H(i,i+1) * Gl(i+1) * H(i+1,i)]&#94;-1 call triMUL_c ( H1i ( ii + 1 )% m , Gl ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B Gl ( ii )% m = inv ( A ) ! !!! Gln(i) = Gl(i) * [Sigma_ph<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)' call triMUL_c ( H1i ( ii + 1 )% m , Gln ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmal ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = transpose ( H1i ( 1 )% m ) ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H1i ( 1 )% m , G00 , H1i ( 1 )% m , sigmal , 'c' , 'n' , 'n' ) ! !$omp critical open ( unit = 10 , file = 'sancho_g00.dat' , position = 'append' ) write ( 10 , * ) En , 1 , - aimag ( trace ( G00 )) close ( 10 ) open ( unit = 10 , file = 'sancho_gbb.dat' , position = 'append' ) write ( 10 , * ) En , 1 , - aimag ( trace ( Gbb )) close ( 10 ) !$omp end critical ! call triMUL_c ( H1i ( 2 )% m , Gl ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( 1 )% m - H00 - B - sigmal ! G_r ( 1 )% m = inv ( A ) Gl ( 1 )% m = G_r ( 1 )% m ! !!! Sigma&#94;< = Sigma_11&#94;< + Sigma_ph&#94;< + Sigma_s&#94;< call triMUL_c ( H1i ( 2 )% m , Gln ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( 1 )% m , Sii ( 1 )% m , 'n' , 'n' , A ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !!! G&#94;< = G * Sigma&#94;< * G' call triMUL_c ( G_r ( 1 )% m , sig , G_r ( 1 )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( 1 )% m = B G_greater ( 1 )% m = G_lesser ( 1 )% m + ( G_r ( 1 )% m - transpose ( conjg ( G_r ( 1 )% m ))) ! A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( 1 )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( 1 )% m , 'n' , 'n' , C ) ! Jdens ( 1 )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( 1 )% m ( jj , jj )) end do tre = tim deallocate ( sigmal , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! inside device l -> r do ii = 2 , nx M = size ( Hii ( ii )% m , 1 ) !!! A = G<(i-1) * H(i-1,i) * Gl(i)' + G(i-1) * H(i-1,i) * Gln(i) call triMUL_c ( G_lesser ( ii - 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii - 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !!! B = H(i,i-1) * A !!! Jdens(i) = -2 * re(B) call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * dble ( B (:, :)) ! !!! GN0 = Gl(i) * H(i,i-1) * G(i-1) !!! G(i) = Gl(i) + GN0 * H(i-1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii - 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !!! G<(i) = Gln(i) + Gl(i) * H(i,i-1) * G<(i-1) * H(i-1,i) *Gl(i)' call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii - 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !!! G<(i) = G<(i) + GNO * H(i-1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !!! G<(i) = G<(i) + Gln(i) * H(i,i-1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !!! G>(i) = G<(i) + (G(i) - G(i)') G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ii = nx ! on the right contact A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tr = tim deallocate ( B , A , C , GN0 , sigmar ) ! end subroutine rgf_variableblock_backward","tags":"","loc":"proc/rgf_variableblock_backward.html"},{"title":"array_eye – Quantum transport simulator","text":"public pure function array_eye(n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n) Called by proc~~array_eye~~CalledByGraph proc~array_eye matrix_c::array_eye interface~eye matrix_c::eye interface~eye->proc~array_eye proc~array_power matrix_c::array_power proc~array_power->proc~array_eye interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_eye Source Code pure function array_eye ( n ) result ( R ) implicit none integer , intent ( in ) :: n complex ( 8 ) :: R ( n , n ) INTEGER :: ii R = dcmplx ( 0.0d0 , 0.0d0 ) forall ( ii = 1 : n ) R ( ii , ii ) = dcmplx ( 1.0d0 , 0.0d0 ) end function array_eye","tags":"","loc":"proc/array_eye.html"},{"title":"matrix_list_size – Quantum transport simulator","text":"public pure function matrix_list_size(list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) Called by proc~~matrix_list_size~~CalledByGraph proc~matrix_list_size matrix_c::matrix_list_size interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_list_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_size Source Code pure function matrix_list_size ( list , dim ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) integer , intent ( in ) :: dim INTEGER :: nm ( size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm ( ii ) = list ( ii )% size ( dim ) end function matrix_list_size","tags":"","loc":"proc/matrix_list_size.html"},{"title":"matrix_list_size2 – Quantum transport simulator","text":"public pure function matrix_list_size2(list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list)) Called by proc~~matrix_list_size2~~CalledByGraph proc~matrix_list_size2 matrix_c::matrix_list_size2 interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_list_size2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_size2 Source Code pure function matrix_list_size2 ( list ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) INTEGER :: nm ( 2 , size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm (:, ii ) = list ( ii )% size (:) end function matrix_list_size2","tags":"","loc":"proc/matrix_list_size2.html"},{"title":"array_size – Quantum transport simulator","text":"public pure function array_size(this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) Called by proc~~array_size~~CalledByGraph proc~array_size matrix_c::array_size interface~sizeof matrix_c::sizeof interface~sizeof->proc~array_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_size Source Code pure function array_size ( this ) result ( s ) implicit none complex ( 8 ), intent ( in ) :: this (:, :) integer :: s ( 2 ), ii FORALL ( ii = 1 : 2 ) s ( ii ) = size ( this , dim = ii ) end function array_size","tags":"","loc":"proc/array_size.html"},{"title":"matrix_size – Quantum transport simulator","text":"public pure function matrix_size(this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) Called by proc~~matrix_size~~CalledByGraph proc~matrix_size matrix_c::matrix_size interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_size Source Code pure function matrix_size ( this ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer :: s ( 2 ) s (:) = this % size end function matrix_size","tags":"","loc":"proc/matrix_size.html"},{"title":"matrix_size_dim – Quantum transport simulator","text":"public pure function matrix_size_dim(this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer Called by proc~~matrix_size_dim~~CalledByGraph proc~matrix_size_dim matrix_c::matrix_size_dim interface~sizeof matrix_c::sizeof interface~sizeof->proc~matrix_size_dim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_size_dim Source Code pure function matrix_size_dim ( this , dim ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: s s = this % size ( dim ) end function matrix_size_dim","tags":"","loc":"proc/matrix_size_dim.html"},{"title":"array_testHermitian – Quantum transport simulator","text":"public pure function array_testHermitian(M) result(b) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: M (:,:) Return Value logical Contents Source Code array_testHermitian Source Code pure function array_testHermitian ( M ) result ( b ) implicit none complex ( 8 ), intent ( in ) :: M (:, :) logical :: b integer :: i , j real ( 8 ), parameter :: TOL = 1.0D-10 b = . true . do i = 1 , size ( M , 2 ) do j = 1 , i if ( abs ( M ( i , j ) - conjg ( M ( j , i ))) . gt . TOL ) then b = . false . return end if end do end do end function array_testHermitian","tags":"","loc":"proc/array_testhermitian.html"},{"title":"array_times_array_dagger – Quantum transport simulator","text":"public pure function array_times_array_dagger(A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1)) Calls proc~~array_times_array_dagger~~CallsGraph proc~array_times_array_dagger matrix_c::array_times_array_dagger proc~array_times_array matrix_c::array_times_array proc~array_times_array_dagger->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_times_array_dagger~~CalledByGraph proc~array_times_array_dagger matrix_c::array_times_array_dagger interface~operator(.md.) matrix_c::operator(.md.) interface~operator(.md.)->proc~array_times_array_dagger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_times_array_dagger Source Code pure function array_times_array_dagger ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 1 )) C = array_times_array ( A , B , trA = . false ., trB = . true ., cjA = . false ., cjB = . true .) end function array_times_array_dagger","tags":"","loc":"proc/array_times_array_dagger.html"},{"title":"array_dagger_times_array – Quantum transport simulator","text":"public pure function array_dagger_times_array(A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2)) Calls proc~~array_dagger_times_array~~CallsGraph proc~array_dagger_times_array matrix_c::array_dagger_times_array proc~array_times_array matrix_c::array_times_array proc~array_dagger_times_array->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_dagger_times_array~~CalledByGraph proc~array_dagger_times_array matrix_c::array_dagger_times_array interface~operator(.dm.) matrix_c::operator(.dm.) interface~operator(.dm.)->proc~array_dagger_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_dagger_times_array Source Code pure function array_dagger_times_array ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 2 ), size ( B , 2 )) C = array_times_array ( A , B , trA = . true ., trB = . false ., cjA = . true ., cjB = . false .) end function array_dagger_times_array","tags":"","loc":"proc/array_dagger_times_array.html"},{"title":"array_times_array – Quantum transport simulator","text":"public pure function array_times_array(A, B, trA, trB, cjA, cjB) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) logical(kind=4), intent(in) :: trA logical(kind=4), intent(in) :: trB logical(kind=4), intent(in), optional :: cjA logical(kind=4), intent(in), optional :: cjB Return Value complex(kind=8), (size(A,merge(2,1,trA)),size(B,merge(1,2,trB))) Called by proc~~array_times_array~~CalledByGraph proc~array_times_array matrix_c::array_times_array proc~array_dagger_times_array matrix_c::array_dagger_times_array proc~array_dagger_times_array->proc~array_times_array proc~array_times_array_dagger matrix_c::array_times_array_dagger proc~array_times_array_dagger->proc~array_times_array proc~array_times_array_simple matrix_c::array_times_array_simple proc~array_times_array_simple->proc~array_times_array interface~operator(.dm.) matrix_c::operator(.dm.) interface~operator(.dm.)->proc~array_dagger_times_array interface~operator(.m.) matrix_c::operator(.m.) interface~operator(.m.)->proc~array_times_array_simple interface~operator(.md.) matrix_c::operator(.md.) interface~operator(.md.)->proc~array_times_array_dagger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_times_array Source Code pure function array_times_array ( A , B , trA , trB , cjA , cjB ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) LOGICAL ( KIND = 4 ), intent ( in ) :: trA , trB complex ( 8 ) :: C ( size ( A , merge ( 2 , 1 , trA )), size ( B , merge ( 1 , 2 , trB ))) LOGICAL ( KIND = 4 ), intent ( in ), optional :: cjA , cjB integer :: lda , ldb , k , m , kb , n character :: ctrA , ctrB interface pure subroutine ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) COMPLEX ( 8 ), intent ( in ) :: ALPHA , BETA INTEGER , intent ( in ) :: K , LDA , LDB , LDC , M , N CHARACTER , intent ( in ) :: TRANSA , TRANSB COMPLEX ( 8 ), intent ( in ) :: A ( lda , * ), B ( ldb , * ) COMPLEX ( 8 ), intent ( inout ) :: C ( ldc , * ) end subroutine ZGEMM end interface lda = size ( A , 1 ) ldb = size ( B , 1 ) if (. not . trA ) then k = size ( A , 2 ) m = size ( A , 1 ) ctrA = 'n' else k = size ( A , 1 ) m = size ( A , 2 ) if ( present ( cjA ) . and . cjA ) then ctrA = 'c' else ctrA = 't' end if end if if (. not . trB ) then kb = size ( B , 1 ) n = size ( B , 2 ) ctrB = 'n' else kb = size ( B , 2 ) n = size ( B , 1 ) if ( present ( cjB ) . and . cjB ) then ctrB = 'c' else ctrB = 't' end if end if call zgemm ( ctrA , ctrB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), C , m ) end function array_times_array","tags":"","loc":"proc/array_times_array.html"},{"title":"array_times_array_simple – Quantum transport simulator","text":"public pure function array_times_array_simple(A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2)) Calls proc~~array_times_array_simple~~CallsGraph proc~array_times_array_simple matrix_c::array_times_array_simple proc~array_times_array matrix_c::array_times_array proc~array_times_array_simple->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_times_array_simple~~CalledByGraph proc~array_times_array_simple matrix_c::array_times_array_simple interface~operator(.m.) matrix_c::operator(.m.) interface~operator(.m.)->proc~array_times_array_simple Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_times_array_simple Source Code pure function array_times_array_simple ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 2 )) C = array_times_array ( A , B , . false ., . false .) end function array_times_array_simple","tags":"","loc":"proc/array_times_array_simple.html"},{"title":"array_power – Quantum transport simulator","text":"public  function array_power(A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) Calls proc~~array_power~~CallsGraph proc~array_power matrix_c::array_power proc~array_eye matrix_c::array_eye proc~array_power->proc~array_eye proc~array_inverse matrix_c::array_inverse proc~array_power->proc~array_inverse zgetrf zgetrf proc~array_inverse->zgetrf zgetri zgetri proc~array_inverse->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_power~~CalledByGraph proc~array_power matrix_c::array_power interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_power Source Code function array_power ( A , n ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: n complex ( 8 ) :: B ( size ( A , 1 ), size ( A , 1 )) complex ( 8 ) :: C ( size ( A , 1 ), size ( A , 1 )) integer :: ii if ( n > 0 ) then B = A do ii = 2 , n B = B . m . A end do C = B elseif ( n == 0 ) then C = array_eye ( size ( A , dim = 1 )) elseif ( n == - 1 ) then C = array_inverse ( A ) else C = array_inverse ( A ) B = C do ii = 2 , - n B = B . m . C end do C = B end if end function array_power","tags":"","loc":"proc/array_power.html"},{"title":"array_transpose – Quantum transport simulator","text":"public pure function array_transpose(A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1)) Called by proc~~array_transpose~~CalledByGraph proc~array_transpose matrix_c::array_transpose interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_transpose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_transpose Source Code pure function array_transpose ( A , t ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) character , intent ( in ) :: t complex ( 8 ) :: C ( size ( A , 2 ), size ( A , 1 )) if (( t == 't' ) . or . ( t == 'T' )) then C = Transpose ( A ) elseif (( t == 'c' ) . or . ( t == 'C' )) then C = Transpose ( Conjg ( A )) end if end function array_transpose","tags":"","loc":"proc/array_transpose.html"},{"title":"array_eigen – Quantum transport simulator","text":"public  function array_eigen(A, B, eigvec, itype, uplo) result(eig) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in), optional :: B (:,:) complex(kind=8), intent(inout), optional :: eigvec (size(A,1),size(A,2)) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: uplo Return Value real(kind=8), (size(A,1)) Calls proc~~array_eigen~~CallsGraph proc~array_eigen matrix_c::array_eigen zheev zheev proc~array_eigen->zheev zhegv zhegv proc~array_eigen->zhegv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_eigen Source Code function array_eigen ( A , B , eigvec , itype , uplo ) result ( eig ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ), intent ( in ), optional :: B (:, :) real ( 8 ) :: eig ( size ( A , 1 )) complex ( 8 ), intent ( inout ), optional :: eigvec ( size ( A , 1 ), size ( A , 2 )) integer , intent ( in ), optional :: itype CHARACTER , intent ( in ), optional :: uplo integer :: LDA , N , LDB , lwork , INFO , itypeop CHARACTER :: jobz , uploop real ( 8 ) :: RWORK ( 3 * size ( A , 2 )) complex ( 8 ) :: work ( 1 + 4 * size ( A , 2 ) + size ( A , 2 ) ** 2 ), C ( size ( A , 1 ), size ( A , 2 )) C (:, :) = A (:, :) if ( present ( eigvec )) then jobz = 'V' else jobz = 'N' end if uploop = merge ( uplo , 'U' , present ( uplo )) itypeop = merge ( itype , 1 , present ( itype )) N = size ( A , dim = 2 ) LDA = size ( A , dim = 1 ) LWORK = size ( WORK ) if ( present ( B )) then LDB = size ( B , dim = 1 ) call zhegv ( itypeop , jobz , uploop , N , C , LDA , B , LDB , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEGV fails with INFO=' , INFO call abort () end if else LDB = LDA call zheev ( jobz , uploop , N , C , LDA , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEEV fails with INFO=' , INFO call abort () end if end if if ( present ( eigvec )) eigvec = C end function array_eigen","tags":"","loc":"proc/array_eigen.html"},{"title":"array_to_diag – Quantum transport simulator","text":"public pure function array_to_diag(A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1)) Called by proc~~array_to_diag~~CalledByGraph proc~array_to_diag matrix_c::array_to_diag interface~diag matrix_c::diag interface~diag->proc~array_to_diag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_to_diag Source Code pure function array_to_diag ( A ) result ( diag ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: diag ( size ( A , 1 )) integer :: ii do concurrent ( ii = 1 : size ( A , 1 )) diag ( ii ) = A ( ii , ii ) end do end function array_to_diag","tags":"","loc":"proc/array_to_diag.html"},{"title":"array_inverse2 – Quantum transport simulator","text":"public  function array_inverse2(A, UPLO) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: UPLO Return Value complex(kind=8), (size(A,dim=1),size(A,dim=1)) Calls proc~~array_inverse2~~CallsGraph proc~array_inverse2 matrix_c::array_inverse2 zhetrf zhetrf proc~array_inverse2->zhetrf zhetri zhetri proc~array_inverse2->zhetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_inverse2 Source Code function array_inverse2 ( A , UPLO ) ! for Hermitian matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: array_inverse2 ( size ( A , dim = 1 ), size ( A , dim = 1 )) CHARACTER , intent ( in ) :: UPLO integer :: info , lda , lwork , n , nnz integer :: ipiv ( size ( A , 1 )) complex ( 8 ), allocatable :: work (:, :) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse2 (:, :) = A (:, :) allocate ( work ( n * n , n * n )) LDA = size ( A , 2 ) call zhetrf ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , size ( WORK ), info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRF fails with INFO=' , info call abort () end if call zhetri ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRI fails with INFO=' , info call abort () end if end function array_inverse2","tags":"","loc":"proc/array_inverse2.html"},{"title":"array_inverse – Quantum transport simulator","text":"public  function array_inverse(A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), dimension(size(A, dim=1), size(A, dim=1)) Calls proc~~array_inverse~~CallsGraph proc~array_inverse matrix_c::array_inverse zgetrf zgetrf proc~array_inverse->zgetrf zgetri zgetri proc~array_inverse->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_inverse~~CalledByGraph proc~array_inverse matrix_c::array_inverse proc~array_power matrix_c::array_power proc~array_power->proc~array_inverse proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->proc~array_inverse interface~operator(ASTERISKASTERISK) matrix_c::operator(**) interface~operator(ASTERISKASTERISK)->proc~array_power Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_inverse Source Code function array_inverse ( A ) ! for General matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: info , n integer :: ipiv ( size ( A , 1 )) complex ( 8 ), dimension ( size ( A , dim = 1 ), size ( A , dim = 1 )) :: array_inverse complex ( 8 ), allocatable :: work (:, :) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse (:, :) = A (:, :) allocate ( work ( n * n , n * n )) call zgetrf ( n , n , array_inverse , n , ipiv , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRF fails with INFO=' , info call abort () end if call zgetri ( n , array_inverse , n , ipiv , work , n * n , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRI fails with INFO=' , info call abort () end if end function array_inverse","tags":"","loc":"proc/array_inverse.html"},{"title":"array_trace – Quantum transport simulator","text":"public pure function array_trace(A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) Called by proc~~array_trace~~CalledByGraph proc~array_trace matrix_c::array_trace interface~trace matrix_c::trace interface~trace->proc~array_trace proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->interface~trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_trace Source Code pure function array_trace ( A ) result ( tr ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: tr integer :: ii tr = sum (( / ( A ( ii , ii ), ii = 1 , size ( A , 1 )) / )) end function array_trace","tags":"","loc":"proc/array_trace.html"},{"title":"matrix_trace – Quantum transport simulator","text":"public elemental function matrix_trace(M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8) Called by proc~~matrix_trace~~CalledByGraph proc~matrix_trace matrix_c::matrix_trace interface~trace matrix_c::trace interface~trace->proc~matrix_trace proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->interface~trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_trace Source Code elemental function matrix_trace ( M ) result ( tr ) implicit none type ( type_matrix_complex ), intent ( in ) :: M complex ( 8 ) :: tr integer :: ii tr = sum (( / ( M % m ( ii , ii ), ii = 1 , M % size ( 1 )) / )) end function matrix_trace","tags":"","loc":"proc/matrix_trace.html"},{"title":"matrix_alloc – Quantum transport simulator","text":"public pure subroutine matrix_alloc(M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) Calls proc~~matrix_alloc~~CallsGraph proc~matrix_alloc matrix_c::matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_alloc->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_alloc~~CalledByGraph proc~matrix_alloc matrix_c::matrix_alloc interface~malloc matrix_c::malloc interface~malloc->proc~matrix_alloc proc~matrix_read matrix_c::matrix_read proc~matrix_read->proc~matrix_alloc interface~readtxt matrix_c::ReadTxt interface~readtxt->proc~matrix_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_alloc Source Code pure subroutine matrix_alloc ( M , n , nn , source ) implicit none type ( type_matrix_complex ), intent ( out ) :: M integer , intent ( in ) :: n integer , intent ( in ), optional :: nn complex ( 8 ), intent ( in ), optional :: source (:, :) if ( present ( nn )) then call matrix_alloc2 ( M , ( / n , nn / ), source = source ) else call matrix_alloc2 ( M , ( / n , n / ), source = source ) end if end subroutine matrix_alloc","tags":"","loc":"proc/matrix_alloc.html"},{"title":"matrix_alloc2 – Quantum transport simulator","text":"public pure subroutine matrix_alloc2(M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) Called by proc~~matrix_alloc2~~CalledByGraph proc~matrix_alloc2 matrix_c::matrix_alloc2 interface~malloc matrix_c::malloc interface~malloc->proc~matrix_alloc2 proc~matrix_alloc matrix_c::matrix_alloc interface~malloc->proc~matrix_alloc proc~matrix_list_allocelem matrix_c::matrix_list_allocElem interface~malloc->proc~matrix_list_allocelem proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 interface~malloc->proc~matrix_list_allocelem2 proc~matrix_alloc->proc~matrix_alloc2 proc~matrix_list_allocelem->proc~matrix_alloc2 proc~matrix_list_allocelem2->proc~matrix_alloc2 proc~matrix_read matrix_c::matrix_read proc~matrix_read->proc~matrix_alloc interface~readtxt matrix_c::ReadTxt interface~readtxt->proc~matrix_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_alloc2 Source Code pure subroutine matrix_alloc2 ( M , n , source ) implicit none type ( type_matrix_complex ), intent ( out ) :: M integer , intent ( in ) :: n ( 2 ) complex ( 8 ), intent ( in ), optional :: source ( 1 : n ( 1 ), 1 : n ( 2 )) if (. not . allocated ( M % m )) then allocate ( M % m ( n ( 1 ), n ( 2 ))) else if (( M % size ( 1 ) == n ( 1 )) . and . ( M % size ( 2 ) == n ( 2 ))) then else deallocate ( M % m ) allocate ( M % m ( n ( 1 ), n ( 2 ))) end if end if if ( present ( source )) then M % m (:, :) = source (:, :) else M % m (:, :) = dcmplx ( 0.0d0 , 0.0d0 ) end if M % size = n end subroutine matrix_alloc2","tags":"","loc":"proc/matrix_alloc2.html"},{"title":"array_alloc – Quantum transport simulator","text":"public pure subroutine array_alloc(M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn Calls proc~~array_alloc~~CallsGraph proc~array_alloc matrix_c::array_alloc proc~array_alloc2 matrix_c::array_alloc2 proc~array_alloc->proc~array_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~array_alloc~~CalledByGraph proc~array_alloc matrix_c::array_alloc interface~malloc matrix_c::malloc interface~malloc->proc~array_alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_alloc Source Code pure subroutine array_alloc ( M , n , nn ) implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n integer , intent ( in ), optional :: nn if ( present ( nn )) then call array_alloc2 ( M , ( / n , nn / )) else call array_alloc2 ( M , ( / n , n / )) end if end subroutine array_alloc","tags":"","loc":"proc/array_alloc.html"},{"title":"array_alloc2 – Quantum transport simulator","text":"public pure subroutine array_alloc2(M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2) Called by proc~~array_alloc2~~CalledByGraph proc~array_alloc2 matrix_c::array_alloc2 interface~malloc matrix_c::malloc interface~malloc->proc~array_alloc2 proc~array_alloc matrix_c::array_alloc interface~malloc->proc~array_alloc proc~array_alloc->proc~array_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_alloc2 Source Code pure subroutine array_alloc2 ( M , n ) !! This function allocates a 2D complex array. If the array is already allocated, this function !! will resize the array to the new size. The allocated array is initiated to zero. implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n ( 2 ) if (. not . allocated ( M )) then allocate ( M ( n ( 1 ), n ( 2 ))) else if (( size ( M , 1 ) == n ( 1 )) . and . ( size ( M , 2 ) == n ( 2 ))) then else deallocate ( M ) allocate ( M ( n ( 1 ), n ( 2 ))) end if end if M = dcmplx ( 0.0d0 , 0.0d0 ) end subroutine array_alloc2","tags":"","loc":"proc/array_alloc2.html"},{"title":"matrix_list_allocElem – Quantum transport simulator","text":"public pure subroutine matrix_list_allocElem(this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices Calls proc~~matrix_list_allocelem~~CallsGraph proc~matrix_list_allocelem matrix_c::matrix_list_allocElem proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_list_allocelem->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_list_allocelem~~CalledByGraph proc~matrix_list_allocelem matrix_c::matrix_list_allocElem interface~malloc matrix_c::malloc interface~malloc->proc~matrix_list_allocelem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_allocElem Source Code pure subroutine matrix_list_allocElem ( this , nx , nm , nn , source ) implicit none integer , intent ( in ) :: nx integer , intent ( in ) :: nm ( 1 : nx ) integer , intent ( in ), optional :: nn ( 1 : nx ) type ( type_matrix_complex ), intent ( out ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx if ( present ( nn )) then call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nn ( ii ) / ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nm ( ii ) / ), source = source (:, :, ii )) end if end do end subroutine matrix_list_allocElem","tags":"","loc":"proc/matrix_list_allocelem.html"},{"title":"matrix_list_allocElem2 – Quantum transport simulator","text":"public pure subroutine matrix_list_allocElem2(this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices Calls proc~~matrix_list_allocelem2~~CallsGraph proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_list_allocelem2->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_list_allocelem2~~CalledByGraph proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 interface~malloc matrix_c::malloc interface~malloc->proc~matrix_list_allocelem2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_allocElem2 Source Code pure subroutine matrix_list_allocElem2 ( this , nx , n , source ) implicit none integer , intent ( in ) :: nx , n ( 2 , 1 : nx ) type ( type_matrix_complex ), intent ( out ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx call matrix_alloc2 ( this ( ii ), n ( 1 : 2 , ii ), source = source (:, :, ii )) end do end subroutine matrix_list_allocElem2","tags":"","loc":"proc/matrix_list_allocelem2.html"},{"title":"matrix_free – Quantum transport simulator","text":"public elemental subroutine matrix_free(this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this Called by proc~~matrix_free~~CalledByGraph proc~matrix_free matrix_c::matrix_free interface~free matrix_c::free interface~free->proc~matrix_free Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_free Source Code elemental subroutine matrix_free ( this ) implicit none type ( type_matrix_complex ), intent ( out ) :: this if ( allocated ( this % m )) deallocate ( this % m ) end subroutine matrix_free","tags":"","loc":"proc/matrix_free.html"},{"title":"matrix_list_print – Quantum transport simulator","text":"public  subroutine matrix_list_print(handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) Called by proc~~matrix_list_print~~CalledByGraph proc~matrix_list_print matrix_c::matrix_list_print interface~savetxt matrix_c::SaveTxt interface~savetxt->proc~matrix_list_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_list_print Source Code subroutine matrix_list_print ( handle , this ) implicit none type ( type_matrix_complex ), intent ( in ) :: this (:) integer , intent ( in ), optional :: handle integer :: ii , xx , yy if ( present ( handle )) then write ( handle , '(1(i8))' ) size ( this ) do ii = 1 , size ( this ) write ( handle , '(2(i8))' ) this ( ii )% size (:) end do write ( handle , '(es15.4,es15.4)' ) ((( this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) else print '(3(i8),es15.4,es15.4)' , ((( ii , xx , yy , this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) end if end subroutine matrix_list_print","tags":"","loc":"proc/matrix_list_print.html"},{"title":"array_print – Quantum transport simulator","text":"public  subroutine array_print(handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:) Called by proc~~array_print~~CalledByGraph proc~array_print matrix_c::array_print interface~savetxt matrix_c::SaveTxt interface~savetxt->proc~array_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_print Source Code subroutine array_print ( handle , A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: handle integer :: xx , yy write ( handle , '(2(i8))' ) size ( A , 1 ), size ( A , 2 ) write ( handle , '(es15.4,es15.4)' ) (( A ( xx , yy ), xx = 1 , size ( A , 1 )), yy = 1 , size ( A , 2 )) write ( handle , '(A)' ) \"END\" end subroutine array_print","tags":"","loc":"proc/array_print.html"},{"title":"matrix_read – Quantum transport simulator","text":"public  subroutine matrix_read(handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A Calls proc~~matrix_read~~CallsGraph proc~matrix_read matrix_c::matrix_read proc~matrix_alloc matrix_c::matrix_alloc proc~matrix_read->proc~matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_alloc->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~matrix_read~~CalledByGraph proc~matrix_read matrix_c::matrix_read interface~readtxt matrix_c::ReadTxt interface~readtxt->proc~matrix_read Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code matrix_read Source Code subroutine matrix_read ( handle , A ) implicit none type ( type_matrix_complex ), intent ( out ) :: A integer , intent ( in ) :: handle integer :: xx , yy real ( 8 ) :: re , im character ( len = 100 ) :: s read ( handle , * ) xx , yy call matrix_alloc ( A , xx , yy ) read ( handle , '(100A)' ) s do while ( trim ( s ) /= \"END\" ) read ( s , * ) re , im A % m ( xx , yy ) = dcmplx ( re , im ) read ( handle , '(100A)' ) s end do end subroutine matrix_read","tags":"","loc":"proc/matrix_read.html"},{"title":"array_print_on_screen – Quantum transport simulator","text":"public  subroutine array_print_on_screen(A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Called by proc~~array_print_on_screen~~CalledByGraph proc~array_print_on_screen matrix_c::array_print_on_screen interface~show matrix_c::show interface~show->proc~array_print_on_screen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code array_print_on_screen Source Code subroutine array_print_on_screen ( A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: xx , yy do xx = 1 , size ( A , 1 ) print '(10(A,es8.1,\",\",es8.1,\")\"))' , ( \"(\" , A ( xx , yy ), yy = 1 , size ( A , 2 )) end do end subroutine array_print_on_screen","tags":"","loc":"proc/array_print_on_screen.html"},{"title":"matrix_copy – Quantum transport simulator","text":"public  subroutine matrix_copy(matrices, tab) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: matrices (:) complex(kind=8), intent(out) :: tab (:,:,:) Contents Source Code matrix_copy Source Code subroutine matrix_copy ( matrices , tab ) implicit none type ( type_matrix_complex ), intent ( in ) :: matrices (:) complex ( 8 ), intent ( out ) :: tab (:, :, :) integer :: i do concurrent ( i = 1 : size ( matrices )) tab ( 1 : matrices ( i )% size ( 1 ), 1 : matrices ( i )% size ( 2 ), i ) = matrices ( i )% m (:, :) end do end subroutine matrix_copy","tags":"","loc":"proc/matrix_copy.html"},{"title":"triMUL_C – Quantum transport simulator","text":"public  subroutine triMUL_C(A, B, C, R, trA, trB, trC) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in), dimension(:, :) :: A complex(kind=8), intent(in), dimension(:, :) :: B complex(kind=8), intent(in), dimension(:, :) :: C complex(kind=8), intent(inout), allocatable :: R (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB character(len=1), intent(in) :: trC Calls proc~~trimul_c~~CallsGraph proc~trimul_c matrix_c::triMUL_C proc~mul_c matrix_c::MUL_C proc~trimul_c->proc~mul_c zgemm zgemm proc~mul_c->zgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~trimul_c~~CalledByGraph proc~trimul_c matrix_c::triMUL_C proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->proc~trimul_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code triMUL_C Source Code subroutine triMUL_C ( A , B , C , R , trA , trB , trC ) complex ( 8 ), intent ( in ), dimension (:, :) :: A , B , C complex ( 8 ), intent ( inout ), allocatable :: R (:, :) character , intent ( in ) :: trA , trB , trC complex ( 8 ), allocatable , dimension (:, :) :: tmp integer :: n , m , k , kb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trB is wrong: \" , trB call abort () end if if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in triMUL_C! Matrix dimension is wrong\" , k , kb call abort () end if call MUL_C ( A , B , trA , trB , tmp ) call MUL_C ( tmp , C , 'n' , trC , R ) deallocate ( tmp ) end subroutine triMUL_C","tags":"","loc":"proc/trimul_c.html"},{"title":"MUL_C – Quantum transport simulator","text":"public  subroutine MUL_C(A, B, trA, trB, R) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB complex(kind=8), intent(inout), allocatable :: R (:,:) Calls proc~~mul_c~~CallsGraph proc~mul_c matrix_c::MUL_C zgemm zgemm proc~mul_c->zgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mul_c~~CalledByGraph proc~mul_c matrix_c::MUL_C proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->proc~mul_c proc~trimul_c matrix_c::triMUL_C proc~rgf_variableblock_backward->proc~trimul_c proc~trimul_c->proc~mul_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Source Code MUL_C Source Code subroutine MUL_C ( A , B , trA , trB , R ) complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ), intent ( inout ), allocatable :: R (:, :) CHARACTER , intent ( in ) :: trA , trB integer :: n , m , k , kb , lda , ldb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trB is wrong: \" , trB call abort () end if lda = size ( A , 1 ) ldb = size ( B , 1 ) if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in MUL_C! Matrix dimension is wrong\" , k , kb call abort () end if if ( allocated ( R )) then if (( size ( R , 1 ) . ne . m ) . or . ( size ( R , 2 ) . ne . n )) then deallocate ( R ) Allocate ( R ( m , n )) end if else Allocate ( R ( m , n )) end if R = dcmplx ( 0.0d0 , 0.0d0 ) call zgemm ( trA , trB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), R , m ) end subroutine MUL_C","tags":"","loc":"proc/mul_c.html"},{"title":"operator(.m.) – Quantum transport simulator","text":"public interface operator(.m.) Calls interface~~operator(.m.)~~CallsGraph interface~operator(.m.) matrix_c::operator(.m.) proc~array_times_array_simple matrix_c::array_times_array_simple interface~operator(.m.)->proc~array_times_array_simple proc~array_times_array matrix_c::array_times_array proc~array_times_array_simple->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_times_array_simple Module Procedures public pure function array_times_array_simple (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2))","tags":"","loc":"interface/operator(.m.).html"},{"title":"operator(**) – Quantum transport simulator","text":"public interface operator(**) Calls interface~~operator(ASTERISKASTERISK)~~CallsGraph interface~operator(ASTERISKASTERISK) matrix_c::operator(**) proc~array_power matrix_c::array_power interface~operator(ASTERISKASTERISK)->proc~array_power proc~array_transpose matrix_c::array_transpose interface~operator(ASTERISKASTERISK)->proc~array_transpose proc~array_eye matrix_c::array_eye proc~array_power->proc~array_eye proc~array_inverse matrix_c::array_inverse proc~array_power->proc~array_inverse zgetrf zgetrf proc~array_inverse->zgetrf zgetri zgetri proc~array_inverse->zgetri Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_power array_transpose Module Procedures public  function array_power (A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) public pure function array_transpose (A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1))","tags":"","loc":"interface/operator(ASTERISKASTERISK).html"},{"title":"operator(.md.) – Quantum transport simulator","text":"public interface operator(.md.) Calls interface~~operator(.md.)~~CallsGraph interface~operator(.md.) matrix_c::operator(.md.) proc~array_times_array_dagger matrix_c::array_times_array_dagger interface~operator(.md.)->proc~array_times_array_dagger proc~array_times_array matrix_c::array_times_array proc~array_times_array_dagger->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_times_array_dagger Module Procedures public pure function array_times_array_dagger (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1))","tags":"","loc":"interface/operator(.md.).html"},{"title":"operator(.dm.) – Quantum transport simulator","text":"public interface operator(.dm.) Calls interface~~operator(.dm.)~~CallsGraph interface~operator(.dm.) matrix_c::operator(.dm.) proc~array_dagger_times_array matrix_c::array_dagger_times_array interface~operator(.dm.)->proc~array_dagger_times_array proc~array_times_array matrix_c::array_times_array proc~array_dagger_times_array->proc~array_times_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_dagger_times_array Module Procedures public pure function array_dagger_times_array (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2))","tags":"","loc":"interface/operator(.dm.).html"},{"title":"sizeof – Quantum transport simulator","text":"public interface sizeof Calls interface~~sizeof~~CallsGraph interface~sizeof matrix_c::sizeof proc~array_size matrix_c::array_size interface~sizeof->proc~array_size proc~matrix_list_size matrix_c::matrix_list_size interface~sizeof->proc~matrix_list_size proc~matrix_list_size2 matrix_c::matrix_list_size2 interface~sizeof->proc~matrix_list_size2 proc~matrix_size matrix_c::matrix_size interface~sizeof->proc~matrix_size proc~matrix_size_dim matrix_c::matrix_size_dim interface~sizeof->proc~matrix_size_dim Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_size matrix_size matrix_list_size matrix_size_dim matrix_list_size2 Module Procedures public pure function array_size (this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) public pure function matrix_size (this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) public pure function matrix_list_size (list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) public pure function matrix_size_dim (this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function matrix_list_size2 (list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list))","tags":"","loc":"interface/sizeof.html"},{"title":"ReadTxt – Quantum transport simulator","text":"public interface ReadTxt Calls interface~~readtxt~~CallsGraph interface~readtxt matrix_c::ReadTxt proc~matrix_read matrix_c::matrix_read interface~readtxt->proc~matrix_read proc~matrix_alloc matrix_c::matrix_alloc proc~matrix_read->proc~matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 proc~matrix_alloc->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_read Module Procedures public  subroutine matrix_read (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A","tags":"","loc":"interface/readtxt.html"},{"title":"SaveTxt – Quantum transport simulator","text":"public interface SaveTxt Calls interface~~savetxt~~CallsGraph interface~savetxt matrix_c::SaveTxt proc~array_print matrix_c::array_print interface~savetxt->proc~array_print proc~matrix_list_print matrix_c::matrix_list_print interface~savetxt->proc~matrix_list_print Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_list_print array_print Module Procedures public  subroutine matrix_list_print (handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) public  subroutine array_print (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:)","tags":"","loc":"interface/savetxt.html"},{"title":"show – Quantum transport simulator","text":"public interface show Calls interface~~show~~CallsGraph interface~show matrix_c::show proc~array_print_on_screen matrix_c::array_print_on_screen interface~show->proc~array_print_on_screen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_print_on_screen Module Procedures public  subroutine array_print_on_screen (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:)","tags":"","loc":"interface/show.html"},{"title":"malloc – Quantum transport simulator","text":"public interface malloc Calls interface~~malloc~~CallsGraph interface~malloc matrix_c::malloc proc~array_alloc matrix_c::array_alloc interface~malloc->proc~array_alloc proc~array_alloc2 matrix_c::array_alloc2 interface~malloc->proc~array_alloc2 proc~matrix_alloc matrix_c::matrix_alloc interface~malloc->proc~matrix_alloc proc~matrix_alloc2 matrix_c::matrix_alloc2 interface~malloc->proc~matrix_alloc2 proc~matrix_list_allocelem matrix_c::matrix_list_allocElem interface~malloc->proc~matrix_list_allocelem proc~matrix_list_allocelem2 matrix_c::matrix_list_allocElem2 interface~malloc->proc~matrix_list_allocelem2 proc~array_alloc->proc~array_alloc2 proc~matrix_alloc->proc~matrix_alloc2 proc~matrix_list_allocelem->proc~matrix_alloc2 proc~matrix_list_allocelem2->proc~matrix_alloc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_list_allocElem2 matrix_list_allocElem matrix_alloc matrix_alloc2 array_alloc array_alloc2 Module Procedures public pure subroutine matrix_list_allocElem2 (this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_list_allocElem (this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_alloc (M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) public pure subroutine matrix_alloc2 (M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) public pure subroutine array_alloc (M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn public pure subroutine array_alloc2 (M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2)","tags":"","loc":"interface/malloc.html"},{"title":"free – Quantum transport simulator","text":"public interface free Calls interface~~free~~CallsGraph interface~free matrix_c::free proc~matrix_free matrix_c::matrix_free interface~free->proc~matrix_free Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures matrix_free Module Procedures public elemental subroutine matrix_free (this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this","tags":"","loc":"interface/free.html"},{"title":"eye – Quantum transport simulator","text":"public interface eye Calls interface~~eye~~CallsGraph interface~eye matrix_c::eye proc~array_eye matrix_c::array_eye interface~eye->proc~array_eye Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_eye Module Procedures public pure function array_eye (n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n)","tags":"","loc":"interface/eye.html"},{"title":"diag – Quantum transport simulator","text":"public interface diag Calls interface~~diag~~CallsGraph interface~diag matrix_c::diag proc~array_to_diag matrix_c::array_to_diag interface~diag->proc~array_to_diag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_to_diag Module Procedures public pure function array_to_diag (A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1))","tags":"","loc":"interface/diag.html"},{"title":"trace – Quantum transport simulator","text":"public interface trace Calls interface~~trace~~CallsGraph interface~trace matrix_c::trace proc~array_trace matrix_c::array_trace interface~trace->proc~array_trace proc~matrix_trace matrix_c::matrix_trace interface~trace->proc~matrix_trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~trace~~CalledByGraph interface~trace matrix_c::trace proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->interface~trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Contents Module Procedures array_trace matrix_trace Module Procedures public pure function array_trace (A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) public elemental function matrix_trace (M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8)","tags":"","loc":"interface/trace.html"},{"title":"negf_mod – Quantum transport simulator","text":"Uses rgf_mod linalg static module~~negf_mod~~UsesGraph module~negf_mod negf_mod linalg linalg module~negf_mod->linalg module~rgf_mod rgf_mod module~negf_mod->module~rgf_mod module~static static module~negf_mod->module~static Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~negf_mod~~UsedByGraph module~negf_mod negf_mod program~main main program~main->module~negf_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents None","tags":"","loc":"module/negf_mod.html"},{"title":"deviceHam_mod – Quantum transport simulator","text":"Used by module~~deviceham_mod~~UsedByGraph module~deviceham_mod deviceHam_mod program~main main program~main->module~deviceham_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines deviceHam_load_COOmatrix deviceHam_build_blocks Subroutines public  subroutine deviceHam_load_COOmatrix (fname, H, nnz, nm, row, col, use0index, complex) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name complex(kind=dp), intent(out), allocatable, dimension(:) :: H integer, intent(out) :: nnz integer, intent(out) :: nm integer, intent(out), allocatable, dimension(:) :: row integer, intent(out), allocatable, dimension(:) :: col logical, intent(in), optional :: use0index logical, intent(in), optional :: complex public  subroutine deviceHam_build_blocks (H, row, col, Hii, H1i, Slices, ext_left, ext_right, num_slice) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), dimension(:) :: H Hamiltonian matrix value in COO integer, intent(in), dimension(:) :: row Hamiltonian matrix index in COO integer, intent(in), dimension(:) :: col Hamiltonian matrix index in COO type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: Hii Hamiltonian blocks type( type_matrix_complex ), intent(inout), dimension(:), allocatable :: H1i Hamiltonian blocks integer, intent(in), dimension(:, :) :: Slices slicing information , refer to graph_partition integer, intent(in) :: ext_left extension on left/right side, number of slices in the central part integer, intent(in) :: ext_right extension on left/right side, number of slices in the central part integer, intent(in) :: num_slice extension on left/right side, number of slices in the central part","tags":"","loc":"module/deviceham_mod.html"},{"title":"static – Quantum transport simulator","text":"Used by module~~static~~UsedByGraph module~static static module~negf_mod negf_mod module~negf_mod->module~static proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->module~static program~main main program~main->module~negf_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Variables dp cone czero c1i hbar m0 eps0 c0 e0 pi twopi m0_ev kg2eV hbar_ev BOLTZ hb2m Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = 8 complex(kind=dp), public, parameter :: cone = dcmplx(1.0d0, 0.0d0) complex(kind=dp), public, parameter :: czero = dcmplx(0.0d0, 0.0d0) complex(kind=dp), public, parameter :: c1i = dcmplx(0.0d0, 1.0d0) real(kind=dp), public, parameter :: hbar = 1.0546d-34 real(kind=dp), public, parameter :: m0 = 9.109d-31 real(kind=dp), public, parameter :: eps0 = 8.854d-12 real(kind=dp), public, parameter :: c0 = 2.998d8 real(kind=dp), public, parameter :: e0 = 1.6022d-19 real(kind=dp), public, parameter :: pi = 3.14159265359d0 real(kind=dp), public, parameter :: twopi = 3.14159265359d0*2.0d0 real(kind=dp), public, parameter :: m0_ev = 5.6856D-16 real(kind=dp), public, parameter :: kg2eV = m0_ev/m0 real(kind=dp), public, parameter :: hbar_ev = 6.58211899E-16 real(kind=dp), public, parameter :: BOLTZ = 8.61734d-05 real(kind=dp), public, parameter :: hb2m = 7.6305d-16","tags":"","loc":"module/static.html"},{"title":"graph_partition – Quantum transport simulator","text":"Library cuts a graph into slices which have only connections with the left\nand right neighbor slices. slice is the main subroutine to call. Contents Interfaces slice Functions getPointsInAllSlices getPointsInSlice testSlicing Subroutines SaveSlicesTxt AddEdge ReadEdgeFromText ReadGraphFromText SaveTxtGraph Interfaces public        interface slice private  subroutine slice_1contact(g, E, S) Procedure returns the slices of the graph going from 1 edge. BFS algorithm is used to\nassign a distance to the edge for each point, then the slice number = distance. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E (:) Left Edge points' IDs integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number private recursive subroutine slice_2contacts(g, E1, E2, NMAX, S) Function returns the slices of the graph. The problem is solved in a divide-and-conquer\nmanner, using recursive bisection method described in [Journal of Computational Physics 228 (2009) 8548–8565]. Compute the left/right distance of points to left/right edges, by calling [[dist]] Divide the graph into 2 'balanced' parts, based on if the right distance is larger than the left distance Find the connections between 2 parts, and define a new set of edges Recursion, Slice seperately the 2 parts Combine the results Stop condition: either the 2 edges touch each other, or the number of points in the remaining part gets\nsmall enough. Note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: E1 (:) Left Edge points' IDs integer, intent(in) :: E2 (:) RightEdge points' IDs integer, intent(in) :: NMAX Maximum number of points in a single slice integer, intent(out), allocatable :: S (:,:) Output the Slices, 2nd index is the Slice number Functions public  function getPointsInAllSlices (S) result(v) Function returns the points in all the slices Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information Return Value integer, (sum(S(1,:))-size(S,2)) public  function getPointsInSlice (S, i) result(v) Function returns the points in a slice number i Arguments Type Intent Optional Attributes Name integer, intent(in) :: S (:,:) Slices information integer, intent(in) :: i Slice number Return Value integer, (S(1,i)-1) public  function testSlicing (g, S) result(b) Function tests if a slicing from subroutine slice of the graph is consistent by\nlooking at the neighbors of all the points in each slice. Arguments Type Intent Optional Attributes Name integer, intent(in) :: g (:,:) Graph connectivity table. integer, intent(in) :: S (:,:) Slices, 2nd index is the Slice number Return Value integer Test result Subroutines public  subroutine SaveSlicesTxt (handle, S, X, Y, Z) Procedure saves the slice information into a text file Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle file unit number integer, intent(in) :: S (:,:) Slices information real(kind=dp), intent(in), optional :: X (:) real(kind=dp), intent(in), optional :: Y (:) real(kind=dp), intent(in), optional :: Z (:) public  subroutine AddEdge (g, ij) Subroutine update the graph data (g) by adding an edge from node-i to node-j.\nThe memory space for (g) is already allocated before calling this procedure Arguments Type Intent Optional Attributes Name integer, intent(out) :: g (:,:) integer, intent(in) :: ij (2) public  subroutine ReadEdgeFromText (fname, E, use0index) Subroutine for reading the edge data from an ASCII text file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: E (:) Edge index logical, intent(in), optional :: use0index public  subroutine ReadGraphFromText (fname, g, threshold, use0index) Subroutine for reading in the graph data from an ASCII text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname input text file name integer, intent(out), allocatable :: g (:,:) Graph connectivity table. real(kind=8), intent(in), optional :: threshold logical, intent(in), optional :: use0index public  subroutine SaveTxtGraph (handle, g) Subroutine for saving the graph data into an ASCII text file. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle Unit number of the input text file integer, intent(in) :: g (:,:) Graph connectivity table.","tags":"","loc":"module/graph_partition.html"},{"title":"rgf_mod – Quantum transport simulator","text":"Recursive Backward Green's solver\nFermi distribution function\nSancho-Rubio Used by module~~rgf_mod~~UsedByGraph module~rgf_mod rgf_mod module~negf_mod negf_mod module~negf_mod->module~rgf_mod program~main main program~main->module~negf_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Subroutines rgf_variableblock_backward Subroutines public  subroutine rgf_variableblock_backward (En, mul, mur, TEMPl, TEMPr, Hii, H1i, Sii, sigma_lesser_ph, sigma_r_ph, G_r, G_lesser, G_greater, Jdens, Gl, Gln, tr, tre) ! H00 = H(i,i) + Sigma_ph(i) * S(i,i)\n! Sigma_R = H(i,i+1) * G00 * H(i+1,i)\n! Gl(i) = [En S(i,i) - H00 - Sigma_R]&#94;-1\n! H00 = H(i,i) + Sigma_ph(i) * S(i,i)\n! Gl(i) = [En S(i,i) - H00 - H(i,i+1) * Gl(i+1) * H(i+1,i)]&#94;-1\n! Gln(i) = Gl(i) * [Sigma_ph<(i) S(i,i) + H(i,i+1) Gln(i+1) H(i+1,i)] * Gl(i)'\n! Sigma&#94;< = Sigma_11&#94;< + Sigma_ph&#94;< + Sigma_s&#94;<\n! G&#94;< = G * Sigma&#94;< * G'\n! A = G<(i-1) * H(i-1,i) * Gl(i)' + G(i-1) * H(i-1,i) * Gln(i)\n! B = H(i,i-1) * A\n! Jdens(i) = -2 * re(B)\n! GN0 = Gl(i) * H(i,i-1) * G(i-1)\n! G(i) = Gl(i) + GN0 * H(i-1,i) * Gl(i)\n! G<(i) = Gln(i) + Gl(i) * H(i,i-1) * G<(i-1) * H(i-1,i) Gl(i)'\n! G<(i) = G<(i) + GNO * H(i-1,i) * Gln(i)\n! G<(i) = G<(i) + Gln(i) * H(i,i-1) * GN0\n! G>(i) = G<(i) + (G(i) - G(i)') Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: En real(kind=dp), intent(in) :: mul (:,:) real(kind=dp), intent(in) :: mur (:,:) real(kind=dp), intent(in) :: TEMPl (:,:) real(kind=dp), intent(in) :: TEMPr (:,:) type( type_matrix_complex ), intent(in) :: Hii (:) type( type_matrix_complex ), intent(in) :: H1i (:) type( type_matrix_complex ), intent(in) :: Sii (:) type( type_matrix_complex ), intent(in) :: sigma_lesser_ph (:) type( type_matrix_complex ), intent(in) :: sigma_r_ph (:) type( type_matrix_complex ), intent(inout) :: G_r (:) type( type_matrix_complex ), intent(inout) :: G_lesser (:) type( type_matrix_complex ), intent(inout) :: G_greater (:) type( type_matrix_complex ), intent(inout) :: Jdens (:) type( type_matrix_complex ), intent(inout) :: Gl (:) type( type_matrix_complex ), intent(inout) :: Gln (:) real(kind=dp), intent(out) :: tr real(kind=dp), intent(out) :: tre","tags":"","loc":"module/rgf_mod.html"},{"title":"matrix_c – Quantum transport simulator","text":"Complex Matrix Library\nA 2D complex array, element to form a list/table of complex matrices Used by module~~matrix_c~~UsedByGraph module~matrix_c matrix_c proc~deviceham_build_blocks deviceHam_mod::deviceHam_build_blocks proc~deviceham_build_blocks->module~matrix_c proc~rgf_variableblock_backward rgf_mod::rgf_variableblock_backward proc~rgf_variableblock_backward->module~matrix_c Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Interfaces operator(.m.) operator(**) operator(.md.) operator(.dm.) sizeof ReadTxt SaveTxt show malloc free eye diag trace Derived Types type_matrix_complex Functions array_eye matrix_list_size matrix_list_size2 array_size matrix_size matrix_size_dim array_testHermitian array_times_array_dagger array_dagger_times_array array_times_array array_times_array_simple array_power array_transpose array_eigen array_to_diag array_inverse2 array_inverse array_trace matrix_trace Subroutines matrix_alloc matrix_alloc2 array_alloc array_alloc2 matrix_list_allocElem matrix_list_allocElem2 matrix_free matrix_list_print array_print matrix_read array_print_on_screen matrix_copy triMUL_C MUL_C Interfaces public        interface operator(.m.) public pure function array_times_array_simple (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2)) public        interface operator(**) public  function array_power (A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) public pure function array_transpose (A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1)) public        interface operator(.md.) public pure function array_times_array_dagger (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1)) public        interface operator(.dm.) public pure function array_dagger_times_array (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2)) public        interface sizeof public pure function array_size (this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) public pure function matrix_size (this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) public pure function matrix_list_size (list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) public pure function matrix_size_dim (this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function matrix_list_size2 (list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list)) public        interface ReadTxt public  subroutine matrix_read (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A public        interface SaveTxt public  subroutine matrix_list_print (handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) public  subroutine array_print (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:) public        interface show public  subroutine array_print_on_screen (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) public        interface malloc public pure subroutine matrix_list_allocElem2 (this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_list_allocElem (this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_alloc (M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) public pure subroutine matrix_alloc2 (M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) public pure subroutine array_alloc (M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn public pure subroutine array_alloc2 (M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2) public        interface free public elemental subroutine matrix_free (this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this public        interface eye public pure function array_eye (n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n) public        interface diag public pure function array_to_diag (A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1)) public        interface trace public pure function array_trace (A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) public elemental function matrix_trace (M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8) Derived Types type, public :: type_matrix_complex Components Type Visibility Attributes Name Initial complex(kind=8), public, allocatable :: m (:,:) complex matrix integer, public :: size (2) matrix size Functions public pure function array_eye (n) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value complex(kind=8), (n,n) public pure function matrix_list_size (list, dim) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) integer, intent(in) :: dim Return Value integer, (size(list)) public pure function matrix_list_size2 (list) result(nm) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: list (:) Return Value integer, (2,size(list)) public pure function array_size (this) result(s) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: this (:,:) Return Value integer, (2) public pure function matrix_size (this) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this Return Value integer, (2) public pure function matrix_size_dim (this, dim) result(s) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: this integer, intent(in) :: dim Return Value integer public pure function array_testHermitian (M) result(b) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: M (:,:) Return Value logical public pure function array_times_array_dagger (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,1)) public pure function array_dagger_times_array (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,2),size(B,2)) public pure function array_times_array (A, B, trA, trB, cjA, cjB) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) logical(kind=4), intent(in) :: trA logical(kind=4), intent(in) :: trB logical(kind=4), intent(in), optional :: cjA logical(kind=4), intent(in), optional :: cjB Return Value complex(kind=8), (size(A,merge(2,1,trA)),size(B,merge(1,2,trB))) public pure function array_times_array_simple (A, B) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) Return Value complex(kind=8), (size(A,1),size(B,2)) public  function array_power (A, n) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) integer, intent(in) :: n Return Value complex(kind=8), (size(A,1),size(A,1)) public pure function array_transpose (A, t) result(C) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: t Return Value complex(kind=8), (size(A,2),size(A,1)) public  function array_eigen (A, B, eigvec, itype, uplo) result(eig) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in), optional :: B (:,:) complex(kind=8), intent(inout), optional :: eigvec (size(A,1),size(A,2)) integer, intent(in), optional :: itype character(len=1), intent(in), optional :: uplo Return Value real(kind=8), (size(A,1)) public pure function array_to_diag (A) result(diag) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), (size(A,1)) public  function array_inverse2 (A, UPLO) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) character(len=1), intent(in) :: UPLO Return Value complex(kind=8), (size(A,dim=1),size(A,dim=1)) public  function array_inverse (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8), dimension(size(A, dim=1), size(A, dim=1)) public pure function array_trace (A) result(tr) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) Return Value complex(kind=8) public elemental function matrix_trace (M) result(tr) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: M Return Value complex(kind=8) Subroutines public pure subroutine matrix_alloc (M, n, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n integer, intent(in), optional :: nn complex(kind=8), intent(in), optional :: source (:,:) public pure subroutine matrix_alloc2 (M, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: M integer, intent(in) :: n (2) complex(kind=8), intent(in), optional :: source (1:n(1),1:n(2)) public pure subroutine array_alloc (M, n, nn) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n integer, intent(in), optional :: nn public pure subroutine array_alloc2 (M, n) This function allocates a 2D complex array. If the array is already allocated, this function\nwill resize the array to the new size. The allocated array is initiated to zero. Arguments Type Intent Optional Attributes Name complex(kind=8), intent(out), allocatable :: M (:,:) integer, intent(in) :: n (2) public pure subroutine matrix_list_allocElem (this, nx, nm, nn, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: nm (1:nx) integer, intent(in), optional :: nn (1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public pure subroutine matrix_list_allocElem2 (this, nx, n, source) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this (1:nx) integer, intent(in) :: nx integer, intent(in) :: n (2,1:nx) complex(kind=8), intent(in), optional :: source (:,:,:) the source data to put into the matrices public elemental subroutine matrix_free (this) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(out) :: this public  subroutine matrix_list_print (handle, this) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: handle type( type_matrix_complex ), intent(in) :: this (:) public  subroutine array_print (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle complex(kind=8), intent(in) :: A (:,:) public  subroutine matrix_read (handle, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handle type( type_matrix_complex ), intent(out) :: A public  subroutine array_print_on_screen (A) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) public  subroutine matrix_copy (matrices, tab) Arguments Type Intent Optional Attributes Name type( type_matrix_complex ), intent(in) :: matrices (:) complex(kind=8), intent(out) :: tab (:,:,:) public  subroutine triMUL_C (A, B, C, R, trA, trB, trC) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in), dimension(:, :) :: A complex(kind=8), intent(in), dimension(:, :) :: B complex(kind=8), intent(in), dimension(:, :) :: C complex(kind=8), intent(inout), allocatable :: R (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB character(len=1), intent(in) :: trC public  subroutine MUL_C (A, B, trA, trB, R) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: A (:,:) complex(kind=8), intent(in) :: B (:,:) character(len=1), intent(in) :: trA character(len=1), intent(in) :: trB complex(kind=8), intent(inout), allocatable :: R (:,:)","tags":"","loc":"module/matrix_c.html"},{"title":"main – Quantum transport simulator","text":"Uses negf_mod deviceHam_mod program~~main~~UsesGraph program~main main module~deviceham_mod deviceHam_mod program~main->module~deviceham_mod module~negf_mod negf_mod program~main->module~negf_mod linalg linalg module~negf_mod->linalg module~rgf_mod rgf_mod module~negf_mod->module~rgf_mod module~static static module~negf_mod->module~static Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Contents Source Code main Source Code PROGRAM main use negf_mod use deviceHam_mod implicit none END PROGRAM main","tags":"","loc":"program/main.html"},{"title":"negf_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~negf_mod.f90~~EfferentGraph sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~negf_mod.f90->sourcefile~rgf_mod.f90 sourcefile~static.f90 static.f90 sourcefile~negf_mod.f90->sourcefile~static.f90 sourcefile~rgf_mod.f90->sourcefile~static.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~rgf_mod.f90->sourcefile~matrix_c.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~negf_mod.f90~~AfferentGraph sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules negf_mod Source Code negf_mod.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! module negf_mod use linalg use static use rgf_mod implicit none private contains end module negf_mod","tags":"","loc":"sourcefile/negf_mod.f90.html"},{"title":"deviceHam_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~deviceham_mod.f90~~EfferentGraph sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~deviceham_mod.f90->sourcefile~matrix_c.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~deviceham_mod.f90~~AfferentGraph sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules deviceHam_mod Source Code deviceHam_mod.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! module deviceHam_mod implicit none private integer , parameter :: dp = 8 public :: deviceHam_load_COOmatrix , deviceHam_build_blocks contains subroutine deviceHam_load_COOmatrix ( fname , H , nnz , nm , row , col , use0index , complex ) character ( len =* ), intent ( in ) :: fname !! input text file name complex ( dp ), allocatable , intent ( out ), dimension (:) :: H integer , allocatable , intent ( out ), dimension (:) :: row , col integer , intent ( out ) :: nnz integer , intent ( out ) :: nm logical , intent ( in ), optional :: use0index , complex logical :: l0index real ( dp ) :: re , im integer :: handle , io integer :: M , NL , i , j , k handle = 101 l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) M = - HUGE ( 1 ) NL = 0 ! Read through the file first to know the number of lines do read ( handle , * , IOSTAT = IO ) i , j , re if ( IO < 0 ) exit if ( max ( i , j ) > M ) M = max ( i , j ) NL = NL + 1 end do print '(\"Number of nonzeros = \",i18)' , NL allocate ( H ( NL )) allocate ( row ( NL )) allocate ( col ( NL )) H = 0.0d0 nnz = NL nm = M ! Read again the file for the matrix rewind handle im = 0.0d0 do k = 1 , NL if (( present ( complex )) . and . complex ) then read ( handle , * ) i , j , re , im else read ( handle , * ) i , j , re end if if ( l0index ) then i = i + 1 j = j + 1 end if row ( k ) = i col ( k ) = j H ( k ) = dcmplx ( re , im ) end do close ( handle ) end subroutine deviceHam_load_COOmatrix subroutine deviceHam_build_blocks ( H , row , col , Hii , H1i , Slices , ext_left , ext_right , num_slice ) use matrix_c , only : type_matrix_complex complex ( dp ), intent ( in ), dimension (:) :: H !! Hamiltonian matrix value in COO integer , intent ( in ), dimension (:) :: row , col !! Hamiltonian matrix index in COO integer , intent ( in ) :: ext_left , ext_right , num_slice !! extension on left/right side, number of slices in the central part type ( type_matrix_complex ), dimension (:), intent ( inout ), allocatable :: Hii , H1i !! Hamiltonian blocks integer , intent ( in ), dimension (:, :) :: Slices !! slicing information , refer to [[graph_partition]] ! ---- integer :: nx allocate ( Hii ( nx )) allocate ( H1i ( nx - 1 )) end subroutine deviceHam_build_blocks end module deviceHam_mod","tags":"","loc":"sourcefile/deviceham_mod.f90.html"},{"title":"static.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~static.f90~~AfferentGraph sourcefile~static.f90 static.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~negf_mod.f90->sourcefile~static.f90 sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~negf_mod.f90->sourcefile~rgf_mod.f90 sourcefile~rgf_mod.f90->sourcefile~static.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules static Source Code static.f90 Source Code MODULE static IMPLICIT NONE integer , parameter :: dp = 8 complex ( dp ), parameter :: cone = dcmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: czero = dcmplx ( 0.0d0 , 0.0d0 ) complex ( dp ), parameter :: c1i = dcmplx ( 0.0d0 , 1.0d0 ) real ( dp ), parameter :: hbar = 1.0546d-34 ! m&#94;2 kg / s real ( dp ), parameter :: m0 = 9.109d-31 ! kg real ( dp ), parameter :: eps0 = 8.854d-12 ! C/V/m real ( dp ), parameter :: c0 = 2.998d8 ! m/s  v light real ( dp ), parameter :: e0 = 1.6022d-19 ! C electron charge REAL ( dp ), PARAMETER :: pi = 3.14159265359d0 REAL ( dp ), PARAMETER :: twopi = 3.14159265359d0 * 2.0d0 REAL ( dp ), PARAMETER :: m0_ev = 5.6856D-16 !eV s&#94;2 / cm&#94;2   rest mass of electron real ( dp ), PARAMETER :: kg2eV = m0_ev / m0 ! eV s&#94;2 / cm&#94;2 / gram REAL ( dp ), PARAMETER :: hbar_ev = 6.58211899E-16 !eV s REAL ( dp ), PARAMETER :: BOLTZ = 8.61734d-05 !eV K-1 real ( dp ), parameter :: hb2m = 7.6305d-16 ! eV*cm&#94;2 END MODULE static","tags":"","loc":"sourcefile/static.f90.html"},{"title":"graph_partition.f90 – Quantum transport simulator","text":"Contents Modules graph_partition Source Code graph_partition.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! ! AUTHOR: Jiang Cao ! module graph_partition !! Library cuts a graph into slices which have only connections with the left !! and right neighbor slices. [[slice]] is the main subroutine to call. implicit none private public :: AddEdge , ReadGraphFromText , SaveSlicesTxt , SaveTxtGraph , testSlicing , slice public :: getPointsInAllSlices , getPointsInSlice , ReadEdgeFromText integer , parameter :: dp = 8 interface slice module procedure slice_1contact , slice_2contacts end interface contains function getPointsInAllSlices ( S ) result ( v ) !! Function returns the points in all the slices implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer :: v ( sum ( S ( 1 , :)) - size ( S , 2 )) integer :: i , n n = 0 do i = 1 , size ( S , 2 ) v ( n + 1 : n + S ( 1 , i ) - 1 ) = S ( 2 : S ( 1 , i ), i ) n = n + S ( 1 , i ) - 1 end do end function getPointsInAllSlices function getPointsInSlice ( S , i ) result ( v ) !! Function returns the points in a slice number `i` implicit none integer , intent ( in ) :: S (:, :) !! Slices information integer , intent ( in ) :: i !! Slice number integer :: v ( S ( 1 , i ) - 1 ) v (:) = S ( 2 : S ( 1 , i ), i ) end function getPointsInSlice subroutine SaveSlicesTxt ( handle , S , X , Y , Z ) !! Procedure saves the slice information into a text file implicit none integer , intent ( in ) :: handle !! file unit number integer , intent ( in ) :: S (:, :) !! Slices information real ( dp ), intent ( in ), optional :: X (:) real ( dp ), intent ( in ), optional :: Y (:) real ( dp ), intent ( in ), optional :: Z (:) integer :: i , j write ( handle , * ) '# number of points in each slice' write ( handle , '(8I10)' ) S ( 1 , :) - 1 ! number of points in each slice if ( present ( X ) . and . present ( Y ) . and . present ( Z )) then write ( handle , * ) '#     X         Y         Z       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(3E15.5,I10)' ) X ( S ( j , i )), Y ( S ( j , i )), Z ( S ( j , i )), i end do end do else write ( handle , * ) '#    Point#       Slice# ' do i = 1 , size ( S , 2 ) do j = 2 , S ( 1 , i ) write ( handle , '(2I10)' ) S ( j , i ), i end do end do end if end subroutine SaveSlicesTxt subroutine AddEdge ( g , ij ) !! Subroutine update the graph data (g) by adding an edge from node-i to node-j. !! The memory space for (g) is already allocated before calling this procedure implicit none integer , intent ( out ) :: g (:, :) integer , intent ( in ) :: ij ( 2 ) ! Find if this Edge is already present in the graph, avoiding duplicates if ( ANY ( g ( 2 : g ( 1 , ij ( 1 )), ij ( 1 )) == ij ( 2 ))) then return else g ( 1 , ij ( 1 )) = g ( 1 , ij ( 1 )) + 1 g ( 1 , ij ( 2 )) = g ( 1 , ij ( 2 )) + 1 g ( g ( 1 , ij ( 2 )), ij ( 2 )) = ij ( 1 ) g ( g ( 1 , ij ( 1 )), ij ( 1 )) = ij ( 2 ) end if end subroutine AddEdge subroutine ReadEdgeFromText ( fname , E , use0index ) !! Subroutine for reading the edge data from an ASCII text file. implicit none integer , allocatable , intent ( out ) :: E (:) !! Edge index character ( len =* ), intent ( in ) :: fname !! input text file name logical , intent ( in ), optional :: use0index integer :: NPT , i integer , parameter :: handle = 677 logical :: l0index l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) read ( handle , * ) NPT ! number of points allocate ( E ( NPT )) read ( handle , * ) E (:) if ( l0index ) E (:) = E (:) + 1 !do i=1,NPT !        read(handle,*) E(i) !        if (l0index) then !          E(i) = E(i)+1 !        endif !enddo close ( handle ) end subroutine ReadEdgeFromText subroutine ReadGraphFromText ( fname , g , threshold , use0index ) !! Subroutine for reading in the graph data from an ASCII text file. !! !! @note The graph connectivity table is stored in a 2D integer array `g(:,:)` which !! is allocated inside this subroutine, so remember to deallocate it outside. !! The 2nd index of `g(:,:)` refers to the point ID and 'g(1,:)-1' is the number of connections !! of the point. The text file should contain 2 columns of integers which are the point !! IDs of 2 connected points in the graph. !! implicit none integer , allocatable , intent ( out ) :: g (:, :) !! Graph connectivity table. character ( len =* ), intent ( in ) :: fname !! input text file name real ( 8 ), intent ( in ), optional :: threshold logical , intent ( in ), optional :: use0index integer , allocatable :: gn (:) !! Temporary array for sizing the Graph Table integer :: i , j , k !! Looping variables integer :: NL !! Number of lines in the text file integer :: IO !! IO state during reading integer :: M !! Number of points in the graph integer :: NC integer , parameter :: handle = 675 logical :: l0index real ( 8 ) :: weight l0index = . false . if ( present ( use0index )) l0index = use0index open ( unit = handle , file = fname ) M = - HUGE ( 1 ) NL = 0 ! Read through the file first to know the number of points in the graph do read ( handle , * , IOSTAT = IO ) i , j if ( l0index ) then i = i + 1 j = j + 1 end if if ( IO < 0 ) exit if ( max ( i , j ) > M ) M = max ( i , j ) NL = NL + 1 end do print '(\"Number of Points = \",i18)' , M allocate ( gn ( M )) gn = 0 ! Read again the file to know about the size of the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if else gn ( i ) = gn ( i ) + 1 gn ( j ) = gn ( j ) + 1 end if end do NC = maxval ( gn ) print '(\"Max Number of Connections = \",i18)' , NC allocate ( g ( NC + 1 , M )) g (:, :) = 0 g ( 1 , :) = 1 deallocate ( gn ) ! Read last time the file for the Graph Table rewind handle do k = 1 , NL if ( present ( threshold )) then read ( handle , * ) i , j , weight else read ( handle , * ) i , j end if if ( l0index ) then i = i + 1 j = j + 1 end if if ( i . ne . j ) then if ( present ( threshold )) then if ( abs ( weight ) > threshold ) then call AddEdge ( g , ( / i , j / )) end if else call AddEdge ( g , ( / i , j / )) end if end if end do close ( handle ) end subroutine ReadGraphFromText subroutine SaveTxtGraph ( handle , g ) !! Subroutine for saving the graph data into an ASCII text file. !! !! @note The 1st column is the point ID, and the following columns are the connecting points' ID. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ), optional :: handle !! Unit number of the input text file character ( len = 1024 ) :: str !! String for FORMAT writing integer :: i !! Looping variable write ( str , \"(I10)\" ) size ( g , 1 ) + 1 if ( present ( handle )) then do i = 1 , size ( g , 2 ) write ( handle , '(' // trim ( adjustl ( str )) // 'i10)' ) i , g ( 2 : g ( 1 , i ), i ) end do else do i = 1 , size ( g , 2 ) print '(' // trim ( adjustl ( str )) // 'i10)' , i , g ( 2 : g ( 1 , i ), i ) end do end if end subroutine SaveTxtGraph subroutine SaveTxt2col ( handle , g ) !! Subroutine for saving the graph data into an ASCII text file with 2 columns format !! !! @note The 1st and 2nd columns are point IDs. Each connection is represented by 1 line. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ), optional :: handle !! Unit number of the input text file integer :: i , j !! Looping variable do i = 1 , size ( g , 2 ) do j = 2 , g ( 1 , i ) if ( i . le . g ( j , i )) then if ( present ( handle )) then write ( handle , '(2i10)' ) i , g ( j , i ) else write ( * , '(2i10)' ) i , g ( j , i ) end if end if end do end do end subroutine SaveTxt2col function dist ( g , E ) result ( D ) !! Function returns the distance of all the points to an edge of the graph. !! Distance means the number of steps needed to arrive at this point starting from the edge !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: E (:) !! Edge points' IDs integer :: D ( 1 : size ( g , 2 )) !! Distance table integer :: ST ( 0 : size ( g , 2 ) * 2 ) !! Circular Stack for BFS algorithm integer :: LST !! Length of the Stack integer :: SLP !! Lower Stack Pointer integer :: SHP !! Higher Stack Pointer integer :: PID !! A point ID integer :: PID2 !! A point ID integer :: i !! Looping integer D (:) = HUGE ( 1 ) D ( E (:)) = 0 SLP = 1 SHP = size ( E ) + 1 ST = 0 ST ( SLP : SHP - 1 ) = E (:) LST = size ( ST ) do while ( SHP . ne . SLP ) PID = ST ( SLP ) ! Take 1 point out from the Stack do i = 2 , g ( 1 , PID ) PID2 = g ( i , PID ) ! Look at its connections if ( D ( PID2 ) . eq . HUGE ( 1 )) then D ( PID2 ) = D ( PID ) + 1 ST ( SHP ) = PID2 ! Push the point into Stack for further moves SHP = MOD ( SHP + 1 , LST ) end if end do SLP = MOD ( SLP + 1 , LST ) end do end function dist function part ( DL , DR ) result ( P ) !! Function returns the partition of a graph depending on the distances to the edges !! obtained from [[edge]] !! implicit none integer , intent ( in ) :: DL (:) !! Distance to the left edge obtained from [[edge]] integer , intent ( in ) :: DR (:) !! Distance to the right edge obtained from [[edge]] integer :: P ( 1 : size ( DL )) !! Partition, 1 for left part, and 2 for right part P = 2 where ( DL < DR ) P = 1 end function part function PtsInParts ( P , PID ) result ( PT ) !! Function returns a list of points' IDs in a partition obtained from [[part]] !! implicit none integer , intent ( in ) :: P (:) !! Partition from [[part]] integer , intent ( in ) :: PID !! Part Number integer :: PT ( COUNT ( P == PID )) !! List of Points in the part #PID integer :: i , j j = 1 do i = 1 , size ( P ) if ( P ( i ) == PID ) then PT ( j ) = i j = j + 1 end if end do end function PtsInParts function edge ( g , P ) result ( E ) !! Function returns the edges of a partition of the graph. !! The partition is obtained from function [[part]] !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: P (:) !! Partition Information from [[part]] integer :: E ( size ( P ), maxval ( P )) !! Edge of each part integer :: i , j !! Loop integers E = 0 E ( 1 , :) = 1 do i = 1 , size ( g , 2 ) ! Loop over all the points do j = 2 , g ( 1 , i ) ! Look up its connecting points if ( P ( g ( j , i )) . ne . P ( i )) then ! They belong to different parts E ( 1 , P ( i )) = E ( 1 , P ( i )) + 1 E ( E ( 1 , P ( i )), P ( i )) = i ! Add this point into the Edge list of part-i exit end if end do end do end function edge function subgraph ( g , PT ) result ( sg ) !! Function returns the sub-graph of a graph by providing a list of points in the sub-graph !! @note The sub-graph has a different point index than the original graph, since it contains !! only the selected points. !! To find the original point index, one has to refer to array PT. For exemple, point `1` !! in the sub-graph corresponds the point `PT(1)` in original graph. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: PT (:) !! List of points in the sub-graph integer :: sg ( size ( g , 1 ) + 1 , size ( PT )) !! Sub-Graph connectivity table integer :: i , j !! Looping integers sg = 0 sg ( 1 , :) = 1 do i = 1 , size ( PT ) do j = 2 , g ( 1 , PT ( i )) if ( ANY ( PT == g ( j , PT ( i )))) then ! point PT(i) connects to a point belonging to PT sg ( 1 , i ) = sg ( 1 , i ) + 1 ! append the connection list of sub-graph sg ( sg ( 1 , i ), i ) = index ( PT , g ( j , PT ( i ))) ! Add the connected point, with new index in sub-graph end if end do end do end function subgraph pure function index ( A , y ) result ( x ) !! Function returns the index of one value y in a list A !! implicit none integer , intent ( in ) :: A (:), y integer :: x , i x = - 1 do i = 1 , size ( A ) if ( y == A ( i )) then x = i exit end if end do end function index function indexes ( A , y ) result ( x ) !! Function returns the index of an array of values y in the list A by calling [[index]] !! implicit none integer , intent ( in ) :: A (:), y (:) integer :: x ( size ( y )), i FORALL ( i = 1 : size ( y )) x ( i ) = index ( A , y ( i )) end function indexes function resize ( A ) result ( B ) !! Function returns a more compact table list by resizing the array !! implicit none integer , intent ( in ) :: A (:, :) !! Table with too many 0, to be compressed integer :: B ( maxval ( A ( 1 , :)), size ( A , 2 )) !! Output resized table B (:, :) = A ( 1 : size ( B , 1 ), :) end function resize subroutine slice_1contact ( g , E , S ) !! Procedure returns the slices of the graph going from 1 edge. BFS algorithm is used to !! assign a distance to the edge for each point, then the slice number = distance. !! !! @note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: E (:) !! Left Edge points' IDs integer , allocatable , intent ( out ) :: S (:, :) !! Output the Slices, 2nd index is the Slice number integer :: D ( size ( g , 2 )) !! Distance table of the points integer :: i , NP D = dist ( g , E ) + 1 ! Add 1 in order to have distance=1 for the edge points NP = - 1 do i = 1 , maxval ( D ) if ( COUNT ( D == i ) > NP ) NP = COUNT ( D == i ) end do allocate ( S ( NP + 1 , maxval ( D ))) S = 1 do i = 1 , size ( g , dim = 2 ) S ( 1 , D ( i )) = S ( 1 , D ( i )) + 1 S ( S ( 1 , D ( i )), D ( i )) = i end do end subroutine slice_1contact recursive subroutine slice_2contacts ( g , E1 , E2 , NMAX , S ) !! Function returns the slices of the graph. The problem is solved in a divide-and-conquer !! manner, using recursive bisection method described in [Journal of Computational Physics 228 (2009) 8548–8565]. !! !! 1. Compute the left/right distance of points to left/right edges, by calling [[dist]] !! 2. Divide the graph into 2 'balanced' parts, based on if the right distance is larger than the left distance !! 3. Find the connections between 2 parts, and define a new set of edges !! 4. Recursion, ``Slice`` seperately the 2 parts !! 5. Combine the results !! !! Stop condition: either the 2 edges touch each other, or the number of points in the remaining part gets !! small enough. !! !! @note S(1,:) indicates the end of the slice, so S(1,:)-1 is the number of points in a slice. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer , intent ( in ) :: E1 (:) !! Left Edge points' IDs integer , intent ( in ) :: E2 (:) !! RightEdge points' IDs integer , intent ( in ) :: NMAX !! Maximum number of points in a single slice integer , allocatable , intent ( out ) :: S (:, :) !! Output the Slices, 2nd index is the Slice number integer :: P ( 1 : size ( g , 2 )) !! Partition table integer :: E ( 1 : size ( g , 2 ), 2 ) !! Edge table integer :: NP ( 2 ) !! Number of points in parts integer , allocatable :: S1 (:, :) !! Slices in the left part integer , allocatable :: S2 (:, :) !! Slices in the right part integer , allocatable :: PT (:) !! Point list in a part integer :: i , err do i = 1 , size ( E1 ) if ( ANY ( E2 (:) == E1 ( i ))) then ! If the 2 edges contact, than we need to put the whole part into one slice allocate ( S ( size ( g , 2 ) + 1 , 1 )) S ( 1 , 1 ) = size ( g , 2 ) + 1 S ( 2 :, 1 ) = ( / ( i , i = 1 , size ( g , 2 )) / ) return end if end do ! Split the Graph into 2 parts P = part ( dist ( g , E1 ), dist ( g , E2 )) FORALL ( i = 1 : 2 ) NP ( i ) = count ( P == i ) ! Determinate the edges E = edge ( g , P ) ! Slice each part ! If a part contains less points than NMAX, than all the points in this part goes into one slice allocate ( PT ( NP ( 1 )), stat = err ) if ( err /= 0 ) print * , \"PT: Allocation request denied\" PT = PtsInParts ( P , 1 ) if (( NP ( 1 ) . gt . NMAX ) . and . ( NP ( 1 ) . gt . size ( E1 ))) then CALL slice ( subgraph ( g , PT ), indexes ( PT , E1 ), indexes ( PT , E ( 2 : E ( 1 , 1 ), 1 )), NMAX , S1 ) ! Recover the original point ID FORALL ( i = 2 : size ( S1 , 1 )) where ( S1 ( i , :) . ne . - 1 ) S1 ( i , :) = PT ( S1 ( i , :)) ! -1 to indicate no number end forall else allocate ( S1 ( NP ( 1 ) + 1 , 1 )) S1 ( 1 , 1 ) = NP ( 1 ) + 1 S1 ( 2 :, 1 ) = PT end if if ( allocated ( PT )) deallocate ( PT , stat = err ) if ( err /= 0 ) print * , \"PT: Deallocation request denied\" allocate ( PT ( NP ( 2 )), stat = err ) if ( err /= 0 ) print * , \"PT: Allocation request denied\" PT = PtsInParts ( P , 2 ) if (( NP ( 2 ) . gt . NMAX ) . and . ( NP ( 2 ) . gt . size ( E2 ))) then CALL slice ( subgraph ( g , PT ), indexes ( PT , E ( 2 : E ( 1 , 2 ), 2 )), indexes ( PT , E2 ), NMAX , S2 ) ! Recover the original point ID FORALL ( i = 2 : size ( S2 , 1 )) where ( S2 ( i , :) . ne . - 1 ) S2 ( i , :) = PT ( S2 ( i , :)) ! -1 to indicate no number end forall else allocate ( S2 ( NP ( 2 ) + 1 , 1 )) S2 ( 1 , 1 ) = NP ( 2 ) + 1 S2 ( 2 :, 1 ) = PT end if if ( allocated ( PT )) deallocate ( PT , stat = err ) if ( err /= 0 ) print * , \"PT: Deallocation request denied\" ! Merge the results of 2 parts allocate ( S ( max ( size ( S1 , 1 ), size ( S2 , 1 )), size ( S1 , 2 ) + size ( S2 , 2 ))) S = - 1 ! -1 to indicate no number S ( 1 : size ( S1 , 1 ), 1 : size ( S1 , 2 )) = S1 S ( 1 : size ( S2 , 1 ), 1 + size ( S1 , 2 ):) = S2 if ( allocated ( S1 )) deallocate ( S1 , stat = err ) if ( err /= 0 ) print * , \"S1: Deallocation request denied\" if ( allocated ( S2 )) deallocate ( S2 , stat = err ) if ( err /= 0 ) print * , \"S2: Deallocation request denied\" end subroutine slice_2contacts function testSlicing ( g , S ) result ( b ) !! Function tests if a slicing from subroutine [[slice]]  of the graph is consistent by !! looking at the neighbors of all the points in each slice. !! implicit none integer , intent ( in ) :: g (:, :) !! Graph connectivity table. integer :: b !! Test result integer , intent ( in ) :: S (:, :) !! Slices, 2nd index is the Slice number integer :: L ( size ( g , 2 )) !! Slice number of points integer :: i , k , j , err L = - 1 L = SliceNum ( S ) IF ( ANY ( L == - 1 )) then b = - 1 ! Not all points belong to a slice return end if do i = 1 , size ( S , 2 ) ! Loop over the slices do j = 2 , S ( 1 , i ) ! Loop over the points in one slice do k = 2 , g ( 1 , S ( j , i )) ! Loop over all its neighbor points if ( abs ( L ( g ( k , S ( j , i ))) - i ) > 1 ) then b = i ! It connects to a points too far print '(4I18)' , L ( g ( k , S ( j , i ))), g ( k , S ( j , i )), i , S ( j , i ) return end if end do end do end do b = 0 end Function testSlicing function SliceNum ( S ) result ( N ) !! Function returns an array of indexes of slice to which the points belong !! implicit none integer , intent ( in ) :: S (:, :) !! Slices, 2nd index is the Slice number integer :: N ( 1 : maxval ( S ( 2 :, :))) !! Slice number of points integer :: i , j do i = 1 , size ( S , 2 ) ! Loop over the slices do j = 2 , S ( 1 , i ) ! Loop over the points in one slice N ( S ( j , i )) = i end do end do end Function SliceNum subroutine ConvertSparseMatrixToGraph ( nnz , IA , JA , G ) !! Subroutine convert a sparse matrix in CSR format into a graph !!   The graph will be allocated inside the subroutine, so remember to deallocate the memory outside implicit none integer , intent ( in ) :: nnz integer , intent ( in ), dimension ( nnz ) :: IA , JA !! IA and JA index vectors of a CSR matrix integer , allocatable , intent ( out ) :: g (:, :) !! Graph connectivity table end subroutine ConvertSparseMatrixToGraph end module graph_partition","tags":"","loc":"sourcefile/graph_partition.f90.html"},{"title":"rgf_mod.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~rgf_mod.f90~~EfferentGraph sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~rgf_mod.f90->sourcefile~matrix_c.f90 sourcefile~static.f90 static.f90 sourcefile~rgf_mod.f90->sourcefile~static.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rgf_mod.f90~~AfferentGraph sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~negf_mod.f90->sourcefile~rgf_mod.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules rgf_mod Source Code rgf_mod.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! ! AUTHOR: Jiang Cao ! module rgf_mod implicit none private integer , parameter :: dp = 8 public :: rgf_variableblock_backward contains !!  Recursive Backward Green's solver subroutine rgf_variableblock_backward ( En , mul , mur , TEMPl , TEMPr , Hii , H1i , Sii , sigma_lesser_ph , & sigma_r_ph , G_r , G_lesser , G_greater , Jdens , Gl , Gln , tr , tre ) use matrix_c , only : type_matrix_complex , MUL_C , triMUL_C , inv => array_inverse , trace use static type ( type_matrix_complex ), intent ( in ) :: Hii (:), H1i (:), Sii (:), sigma_lesser_ph (:), sigma_r_ph (:) real ( dp ), intent ( in ) :: En , mul (:, :), mur (:, :), TEMPr (:, :), TEMPl (:, :) type ( type_matrix_complex ), intent ( inout ) :: G_greater (:), G_lesser (:), G_r (:), Jdens (:), Gl (:), Gln (:) real ( dp ), intent ( out ) :: tr , tre !---- local variables integer :: nx , M , ii , jj complex ( dp ) :: z real ( dp ) :: tim complex ( dp ), allocatable :: sig (:, :), H00 (:, :), H10 (:, :) complex ( dp ), allocatable :: A (:, :), B (:, :), C (:, :), G00 (:, :), GBB (:, :), sigmar (:, :), sigmal (:, :), GN0 (:, :) nx = size ( Hii ) ! <- lenght of the device z = dcmplx ( En , 0.0d0 ) ! ! on the right contact ii = nx M = size ( Hii ( ii )% m , 1 ) allocate ( H00 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sigmar ( M , M )) allocate ( sig ( M , M )) ! !!! H00 = H(i,i) + Sigma_ph(i) * S(i,i) call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) ! H00 = Hii ( ii )% m + B call sancho ( M , En , Sii ( ii )% m , H00 , H1i ( ii + 1 )% m , G00 , GBB ) !$omp critical open ( unit = 10 , file = 'sancho_g00.dat' , position = 'append' ) write ( 10 , * ) En , 2 , - aimag ( trace ( G00 )) close ( 10 ) open ( unit = 10 , file = 'sancho_gbb.dat' , position = 'append' ) write ( 10 , * ) En , 2 , - aimag ( trace ( Gbb )) close ( 10 ) !$omp end critical ! !!! Sigma_R = H(i,i+1) * G00 * H(i+1,i) !!! Gl(i) = [En*S(i,i) - H00 - Sigma_R]&#94;-1 call triMUL_c ( H1i ( ii + 1 )% m , G00 , H1i ( ii + 1 )% m , sigmar , 'n' , 'n' , 'c' ) B = z * Sii ( ii )% m - H00 - sigmar Gl ( ii )% m = inv ( B ) ! ! Gln(i) = Gl(i) * [Sigma_ph<(i)*S(i,i) + (-(Sigma_R - Sigma_R')*ferm(..))] * Gl(i)' call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) sig = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) ! sig = sig + B call triMUL_c ( Gl ( ii )% m , sig , Gl ( ii )% m , B , 'n' , 'n' , 'c' ) Gln ( ii )% m = B deallocate ( G00 , GBB , sig ) ! allocate ( A ( M , M )) ! inside device r -> l do ii = nx - 1 , 2 , - 1 M = size ( Hii ( ii )% m , 1 ) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 , A ) allocate ( H00 ( M , M )) allocate ( A ( M , M )) end if call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B ! !!! H00 = H(i,i) + Sigma_ph(i) * S(i,i) !!! Gl(i) = [En*S(i,i) - H00 - H(i,i+1) * Gl(i+1) * H(i+1,i)]&#94;-1 call triMUL_c ( H1i ( ii + 1 )% m , Gl ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( ii )% m - H00 - B Gl ( ii )% m = inv ( A ) ! !!! Gln(i) = Gl(i) * [Sigma_ph<(i)*S(i,i) + H(i,i+1)*Gln(i+1)*H(i+1,i)] * Gl(i)' call triMUL_c ( H1i ( ii + 1 )% m , Gln ( ii + 1 )% m , H1i ( ii + 1 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , A ) B = B + A call triMUL_c ( Gl ( ii )% m , B , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) Gln ( ii )% m = A end do ! ! on the left contact ii = 1 M = size ( Hii ( ii )% m , 1 ) allocate ( H10 ( M , M )) allocate ( G00 ( M , M )) allocate ( GBB ( M , M )) allocate ( sig ( M , M )) allocate ( sigmal ( M , M )) if ( size ( H00 , 1 ) . ne . M ) then deallocate ( H00 ) allocate ( H00 ( M , M )) end if ! call MUL_c ( sigma_r_ph ( ii )% m , Sii ( ii )% m , 'n' , 'n' , B ) H00 = Hii ( ii )% m + B H10 = transpose ( H1i ( 1 )% m ) ! call sancho ( M , En , Sii ( ii )% m , H00 , H10 , G00 , GBB ) ! call triMUL_c ( H1i ( 1 )% m , G00 , H1i ( 1 )% m , sigmal , 'c' , 'n' , 'n' ) ! !$omp critical open ( unit = 10 , file = 'sancho_g00.dat' , position = 'append' ) write ( 10 , * ) En , 1 , - aimag ( trace ( G00 )) close ( 10 ) open ( unit = 10 , file = 'sancho_gbb.dat' , position = 'append' ) write ( 10 , * ) En , 1 , - aimag ( trace ( Gbb )) close ( 10 ) !$omp end critical ! call triMUL_c ( H1i ( 2 )% m , Gl ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) A = z * Sii ( 1 )% m - H00 - B - sigmal ! G_r ( 1 )% m = inv ( A ) Gl ( 1 )% m = G_r ( 1 )% m ! !!! Sigma&#94;< = Sigma_11&#94;< + Sigma_ph&#94;< + Sigma_s&#94;< call triMUL_c ( H1i ( 2 )% m , Gln ( 2 )% m , H1i ( 2 )% m , B , 'n' , 'n' , 'c' ) call MUL_c ( sigma_lesser_ph ( 1 )% m , Sii ( 1 )% m , 'n' , 'n' , A ) sig = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) sig = sig + A + B ! !!! G&#94;< = G * Sigma&#94;< * G' call triMUL_c ( G_r ( 1 )% m , sig , G_r ( 1 )% m , B , 'n' , 'n' , 'c' ) ! G_lesser ( 1 )% m = B G_greater ( 1 )% m = G_lesser ( 1 )% m + ( G_r ( 1 )% m - transpose ( conjg ( G_r ( 1 )% m ))) ! A = - ( sigmal - transpose ( conjg ( sigmal ))) * ferm (( En - mul ) / ( BOLTZ * TEMPl )) call MUL_c ( A , G_greater ( 1 )% m , 'n' , 'n' , B ) A = - ( sigmal - transpose ( conjg ( sigmal ))) * ( ferm (( En - mul ) / ( BOLTZ * TEMPl )) - 1.0d0 ) call MUL_c ( A , G_lesser ( 1 )% m , 'n' , 'n' , C ) ! Jdens ( 1 )% m = B - C ! tim = 0.0d0 do jj = 1 , M tim = tim + dble ( Jdens ( 1 )% m ( jj , jj )) end do tre = tim deallocate ( sigmal , sig , G00 , GBB , H10 ) allocate ( GN0 ( M , M )) ! ! inside device l -> r do ii = 2 , nx M = size ( Hii ( ii )% m , 1 ) !!! A = G<(i-1) * H(i-1,i) * Gl(i)' + G(i-1) * H(i-1,i) * Gln(i) call triMUL_c ( G_lesser ( ii - 1 )% m , H1i ( ii )% m , Gl ( ii )% m , A , 'n' , 'n' , 'c' ) call triMUL_c ( G_r ( ii - 1 )% m , H1i ( ii )% m , Gln ( ii )% m , B , 'n' , 'n' , 'n' ) A = A + B !!! B = H(i,i-1) * A !!! Jdens(i) = -2 * re(B) call MUL_c ( H1i ( ii )% m , A , 'c' , 'n' , B ) Jdens ( ii )% m = - 2.0d0 * dble ( B (:, :)) ! !!! GN0 = Gl(i) * H(i,i-1) * G(i-1) !!! G(i) = Gl(i) + GN0 * H(i-1,i) * Gl(i) call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_r ( ii - 1 )% m , 'n' , 'n' , GN0 ) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , C ) call MUL_c ( C , Gl ( ii )% m , 'n' , 'n' , A ) G_r ( ii )% m = Gl ( ii )% m + A ! !!! G<(i) = Gln(i) + Gl(i) * H(i,i-1) * G<(i-1) * H(i-1,i) *Gl(i)' call MUL_c ( Gl ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , G_lesser ( ii - 1 )% m , 'n' , 'n' , C ) call MUL_c ( C , H1i ( ii )% m , 'n' , 'n' , A ) call MUL_c ( A , Gl ( ii )% m , 'n' , 'c' , C ) G_lesser ( ii )% m = Gln ( ii )% m + C ! !!! G<(i) = G<(i) + GNO * H(i-1,i) * Gln(i) call MUL_c ( GN0 , H1i ( ii )% m , 'n' , 'n' , B ) call MUL_c ( B , Gln ( ii )% m , 'n' , 'n' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !!! G<(i) = G<(i) + Gln(i) * H(i,i-1) * GN0 call MUL_c ( Gln ( ii )% m , H1i ( ii )% m , 'n' , 'c' , B ) call MUL_c ( B , GN0 , 'n' , 'c' , C ) G_lesser ( ii )% m = G_lesser ( ii )% m + C ! !!! G>(i) = G<(i) + (G(i) - G(i)') G_greater ( ii )% m = G_lesser ( ii )% m + ( G_r ( ii )% m - transpose ( conjg ( G_r ( ii )% m ))) end do ii = nx ! on the right contact A = - ( sigmar - transpose ( conjg ( sigmar ))) * ferm (( En - mur ) / ( BOLTZ * TEMPr )) call MUL_c ( A , G_greater ( ii )% m , 'n' , 'n' , B ) A = - ( sigmar - transpose ( conjg ( sigmar ))) * ( ferm (( En - mur ) / ( BOLTZ * TEMPr )) - 1.0d0 ) call MUL_c ( A , G_lesser ( ii )% m , 'n' , 'n' , C ) tim = 0.0d0 do jj = 1 , M tim = tim + dble ( B ( jj , jj ) - C ( jj , jj )) end do tr = tim deallocate ( B , A , C , GN0 , sigmar ) ! end subroutine rgf_variableblock_backward !!  Fermi distribution function elemental Function ferm ( a ) Real ( dp ), intent ( in ) :: a real ( dp ) :: ferm ferm = 1.0d0 / ( 1.0d0 + Exp ( a )) End Function ferm !!  Sancho-Rubio subroutine sancho ( nm , E , S00 , H00 , H10 , G00 , GBB ) use linalg , only : invert integer i , j , k , nm , nmax COMPLEX ( dp ) :: z real ( dp ) :: E , error REAL ( dp ) :: TOL = 1.0D-100 ! [eV] COMPLEX ( dp ), INTENT ( IN ) :: S00 ( nm , nm ), H00 ( nm , nm ), H10 ( nm , nm ) COMPLEX ( dp ), INTENT ( OUT ) :: G00 ( nm , nm ), GBB ( nm , nm ) COMPLEX ( dp ), ALLOCATABLE :: A (:, :), B (:, :), C (:, :), tmp (:, :) COMPLEX ( dp ), ALLOCATABLE :: H_BB (:, :), H_SS (:, :), H_01 (:, :), H_10 (:, :), Id (:, :) COMPLEX ( dp ), EXTERNAL :: ZLANGE complex ( dp ), parameter :: alpha = cmplx ( 1.0d0 , 0.0d0 ) complex ( dp ), parameter :: beta = cmplx ( 0.0d0 , 0.0d0 ) ! Allocate ( H_BB ( nm , nm )) Allocate ( H_SS ( nm , nm )) Allocate ( H_01 ( nm , nm )) Allocate ( H_10 ( nm , nm )) Allocate ( Id ( nm , nm )) Allocate ( A ( nm , nm )) Allocate ( B ( nm , nm )) Allocate ( C ( nm , nm )) Allocate ( tmp ( nm , nm )) nmax = 50 z = dcmplx ( E , 1.0d-3 ) Id = 0.0d0 tmp = 0.0d0 do i = 1 , nm Id ( i , i ) = 1.0d0 tmp ( i , i ) = dcmplx ( 0.0d0 , 1.0d0 ) end do H_BB = H00 H_10 = H10 H_01 = TRANSPOSE ( CONJG ( H_10 )) H_SS = H00 do i = 1 , nmax A = z * S00 - H_BB call invert ( A , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H_10 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_SS = H_SS + C H_BB = H_BB + C call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , C , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , A , nm , H_01 , nm , beta , B , nm ) call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_10 , nm , B , nm , beta , A , nm ) H_10 = C H_BB = H_BB + A call zgemm ( 'n' , 'n' , nm , nm , nm , alpha , H_01 , nm , B , nm , beta , C , nm ) H_01 = C ! NORM --> inspect the diagonal of A error = 0.0d0 DO k = 1 , nm DO j = 1 , nm error = error + sqrt ( aimag ( C ( k , j )) ** 2 + Dble ( C ( k , j )) ** 2 ) END DO END DO !write(90,*)E,i,error tmp = H_SS IF ( abs ( error ) < TOL ) THEN !write(90,*) 'SR: Exited, abs(error)=',i,abs(error) EXIT ELSE END IF IF ( i . EQ . nmax ) THEN write ( * , * ) 'SEVERE warning: nmax reached in sancho!!!' , error END IF end do G00 = z * S00 - H_SS call invert ( G00 , nm ) ! GBB = z * S00 - H_BB call invert ( GBB , nm ) ! Deallocate ( tmp ) Deallocate ( A ) Deallocate ( B ) Deallocate ( C ) Deallocate ( H_BB ) Deallocate ( H_SS ) Deallocate ( H_01 ) Deallocate ( H_10 ) Deallocate ( Id ) end subroutine sancho end module rgf_mod","tags":"","loc":"sourcefile/rgf_mod.f90.html"},{"title":"main.f90 – Quantum transport simulator","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~deviceham_mod.f90->sourcefile~matrix_c.f90 sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~negf_mod.f90->sourcefile~rgf_mod.f90 sourcefile~static.f90 static.f90 sourcefile~negf_mod.f90->sourcefile~static.f90 sourcefile~rgf_mod.f90->sourcefile~matrix_c.f90 sourcefile~rgf_mod.f90->sourcefile~static.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Programs main Source Code main.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. ! PROGRAM main use negf_mod use deviceHam_mod implicit none END PROGRAM main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"matrix_c.f90 – Quantum transport simulator","text":"Files dependent on this one sourcefile~~matrix_c.f90~~AfferentGraph sourcefile~matrix_c.f90 matrix_c.f90 sourcefile~deviceham_mod.f90 deviceHam_mod.f90 sourcefile~deviceham_mod.f90->sourcefile~matrix_c.f90 sourcefile~rgf_mod.f90 rgf_mod.f90 sourcefile~rgf_mod.f90->sourcefile~matrix_c.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~deviceham_mod.f90 sourcefile~negf_mod.f90 negf_mod.f90 sourcefile~main.f90->sourcefile~negf_mod.f90 sourcefile~negf_mod.f90->sourcefile~rgf_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Contents Modules matrix_c Source Code matrix_c.f90 Source Code ! Copyright (c) 2023 Jiang Cao, ETH Zurich ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright notice, !    this list of conditions and the following disclaimer. ! 2. Redistributions in binary form must reproduce the above copyright notice, !    this list of conditions and the following disclaimer in the documentation !    and/or other materials provided with the distribution. ! 3. Neither the name of the copyright holder nor the names of its contributors !    may be used to endorse or promote products derived from this software without !    specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR ! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF ! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN ! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE ! POSSIBILITY OF SUCH DAMAGE. module matrix_c !! Complex Matrix Library !! A 2D complex array, element to form a list/table of complex matrices implicit none type type_matrix_complex complex ( 8 ), allocatable :: m (:, :) !! complex matrix integer :: size ( 2 ) !! matrix size end type type_matrix_complex interface operator (. m .) module procedure array_times_array_simple end interface interface operator ( ** ) module procedure array_power , & array_transpose end interface interface operator (. md .) module procedure array_times_array_dagger end interface interface operator (. dm .) module procedure array_dagger_times_array end interface interface sizeof module procedure array_size , matrix_size , matrix_list_size , matrix_size_dim , matrix_list_size2 end interface sizeof interface ReadTxt module procedure matrix_read end interface ReadTxt interface SaveTxt module procedure matrix_list_print , array_print end interface SaveTxt interface show module procedure array_print_on_screen end interface show interface malloc module procedure matrix_list_allocElem2 , matrix_list_allocElem module procedure matrix_alloc , matrix_alloc2 , array_alloc , array_alloc2 end interface interface free module procedure matrix_free end interface interface eye module procedure array_eye end interface interface diag module procedure array_to_diag end interface interface trace module procedure array_trace , matrix_trace end interface contains !  =====  Allocation/Deallocation  ===== ! allocate a matrix pure subroutine matrix_alloc ( M , n , nn , source ) implicit none type ( type_matrix_complex ), intent ( out ) :: M integer , intent ( in ) :: n integer , intent ( in ), optional :: nn complex ( 8 ), intent ( in ), optional :: source (:, :) if ( present ( nn )) then call matrix_alloc2 ( M , ( / n , nn / ), source = source ) else call matrix_alloc2 ( M , ( / n , n / ), source = source ) end if end subroutine matrix_alloc ! allocate a matrix pure subroutine matrix_alloc2 ( M , n , source ) implicit none type ( type_matrix_complex ), intent ( out ) :: M integer , intent ( in ) :: n ( 2 ) complex ( 8 ), intent ( in ), optional :: source ( 1 : n ( 1 ), 1 : n ( 2 )) if (. not . allocated ( M % m )) then allocate ( M % m ( n ( 1 ), n ( 2 ))) else if (( M % size ( 1 ) == n ( 1 )) . and . ( M % size ( 2 ) == n ( 2 ))) then else deallocate ( M % m ) allocate ( M % m ( n ( 1 ), n ( 2 ))) end if end if if ( present ( source )) then M % m (:, :) = source (:, :) else M % m (:, :) = dcmplx ( 0.0d0 , 0.0d0 ) end if M % size = n end subroutine matrix_alloc2 ! allocate an array pure subroutine array_alloc ( M , n , nn ) implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n integer , intent ( in ), optional :: nn if ( present ( nn )) then call array_alloc2 ( M , ( / n , nn / )) else call array_alloc2 ( M , ( / n , n / )) end if end subroutine array_alloc pure subroutine array_alloc2 ( M , n ) !! This function allocates a 2D complex array. If the array is already allocated, this function !! will resize the array to the new size. The allocated array is initiated to zero. implicit none complex ( 8 ), intent ( out ), allocatable :: M (:, :) integer , intent ( in ) :: n ( 2 ) if (. not . allocated ( M )) then allocate ( M ( n ( 1 ), n ( 2 ))) else if (( size ( M , 1 ) == n ( 1 )) . and . ( size ( M , 2 ) == n ( 2 ))) then else deallocate ( M ) allocate ( M ( n ( 1 ), n ( 2 ))) end if end if M = dcmplx ( 0.0d0 , 0.0d0 ) end subroutine array_alloc2 pure function array_eye ( n ) result ( R ) implicit none integer , intent ( in ) :: n complex ( 8 ) :: R ( n , n ) INTEGER :: ii R = dcmplx ( 0.0d0 , 0.0d0 ) forall ( ii = 1 : n ) R ( ii , ii ) = dcmplx ( 1.0d0 , 0.0d0 ) end function array_eye pure subroutine matrix_list_allocElem ( this , nx , nm , nn , source ) implicit none integer , intent ( in ) :: nx integer , intent ( in ) :: nm ( 1 : nx ) integer , intent ( in ), optional :: nn ( 1 : nx ) type ( type_matrix_complex ), intent ( out ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx if ( present ( nn )) then call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nn ( ii ) / ), source = source (:, :, ii )) else call matrix_alloc2 ( this ( ii ), ( / nm ( ii ), nm ( ii ) / ), source = source (:, :, ii )) end if end do end subroutine matrix_list_allocElem pure subroutine matrix_list_allocElem2 ( this , nx , n , source ) implicit none integer , intent ( in ) :: nx , n ( 2 , 1 : nx ) type ( type_matrix_complex ), intent ( out ) :: this ( 1 : nx ) complex ( 8 ), intent ( in ), optional :: source (:, :, :) !! the source data to put into the matrices integer :: ii do ii = 1 , nx call matrix_alloc2 ( this ( ii ), n ( 1 : 2 , ii ), source = source (:, :, ii )) end do end subroutine matrix_list_allocElem2 elemental subroutine matrix_free ( this ) implicit none type ( type_matrix_complex ), intent ( out ) :: this if ( allocated ( this % m )) deallocate ( this % m ) end subroutine matrix_free !  =====  size, print  ===== pure function matrix_list_size ( list , dim ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) integer , intent ( in ) :: dim INTEGER :: nm ( size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm ( ii ) = list ( ii )% size ( dim ) end function matrix_list_size pure function matrix_list_size2 ( list ) result ( nm ) implicit none type ( type_matrix_complex ), intent ( in ) :: list (:) INTEGER :: nm ( 2 , size ( list )) integer :: ii forall ( ii = 1 : size ( list )) nm (:, ii ) = list ( ii )% size (:) end function matrix_list_size2 pure function array_size ( this ) result ( s ) implicit none complex ( 8 ), intent ( in ) :: this (:, :) integer :: s ( 2 ), ii FORALL ( ii = 1 : 2 ) s ( ii ) = size ( this , dim = ii ) end function array_size pure function matrix_size ( this ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer :: s ( 2 ) s (:) = this % size end function matrix_size pure function matrix_size_dim ( this , dim ) result ( s ) implicit none type ( type_matrix_complex ), intent ( in ) :: this integer , intent ( in ) :: dim integer :: s s = this % size ( dim ) end function matrix_size_dim subroutine matrix_list_print ( handle , this ) implicit none type ( type_matrix_complex ), intent ( in ) :: this (:) integer , intent ( in ), optional :: handle integer :: ii , xx , yy if ( present ( handle )) then write ( handle , '(1(i8))' ) size ( this ) do ii = 1 , size ( this ) write ( handle , '(2(i8))' ) this ( ii )% size (:) end do write ( handle , '(es15.4,es15.4)' ) ((( this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) else print '(3(i8),es15.4,es15.4)' , ((( ii , xx , yy , this ( ii )% m ( xx , yy ), & xx = 1 , size ( this ( ii )% m , 1 )), yy = 1 , size ( this ( ii )% m , 2 )), ii = 1 , size ( this )) end if end subroutine matrix_list_print subroutine array_print ( handle , A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: handle integer :: xx , yy write ( handle , '(2(i8))' ) size ( A , 1 ), size ( A , 2 ) write ( handle , '(es15.4,es15.4)' ) (( A ( xx , yy ), xx = 1 , size ( A , 1 )), yy = 1 , size ( A , 2 )) write ( handle , '(A)' ) \"END\" end subroutine array_print subroutine matrix_read ( handle , A ) implicit none type ( type_matrix_complex ), intent ( out ) :: A integer , intent ( in ) :: handle integer :: xx , yy real ( 8 ) :: re , im character ( len = 100 ) :: s read ( handle , * ) xx , yy call matrix_alloc ( A , xx , yy ) read ( handle , '(100A)' ) s do while ( trim ( s ) /= \"END\" ) read ( s , * ) re , im A % m ( xx , yy ) = dcmplx ( re , im ) read ( handle , '(100A)' ) s end do end subroutine matrix_read subroutine array_print_on_screen ( A ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: xx , yy do xx = 1 , size ( A , 1 ) print '(10(A,es8.1,\",\",es8.1,\")\"))' , ( \"(\" , A ( xx , yy ), yy = 1 , size ( A , 2 )) end do end subroutine array_print_on_screen pure function array_testHermitian ( M ) result ( b ) implicit none complex ( 8 ), intent ( in ) :: M (:, :) logical :: b integer :: i , j real ( 8 ), parameter :: TOL = 1.0D-10 b = . true . do i = 1 , size ( M , 2 ) do j = 1 , i if ( abs ( M ( i , j ) - conjg ( M ( j , i ))) . gt . TOL ) then b = . false . return end if end do end do end function array_testHermitian !  =====  Multiplications and others  ===== pure function array_times_array_dagger ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 1 )) C = array_times_array ( A , B , trA = . false ., trB = . true ., cjA = . false ., cjB = . true .) end function array_times_array_dagger pure function array_dagger_times_array ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 2 ), size ( B , 2 )) C = array_times_array ( A , B , trA = . true ., trB = . false ., cjA = . true ., cjB = . false .) end function array_dagger_times_array pure function array_times_array ( A , B , trA , trB , cjA , cjB ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) LOGICAL ( KIND = 4 ), intent ( in ) :: trA , trB complex ( 8 ) :: C ( size ( A , merge ( 2 , 1 , trA )), size ( B , merge ( 1 , 2 , trB ))) LOGICAL ( KIND = 4 ), intent ( in ), optional :: cjA , cjB integer :: lda , ldb , k , m , kb , n character :: ctrA , ctrB interface pure subroutine ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) COMPLEX ( 8 ), intent ( in ) :: ALPHA , BETA INTEGER , intent ( in ) :: K , LDA , LDB , LDC , M , N CHARACTER , intent ( in ) :: TRANSA , TRANSB COMPLEX ( 8 ), intent ( in ) :: A ( lda , * ), B ( ldb , * ) COMPLEX ( 8 ), intent ( inout ) :: C ( ldc , * ) end subroutine ZGEMM end interface lda = size ( A , 1 ) ldb = size ( B , 1 ) if (. not . trA ) then k = size ( A , 2 ) m = size ( A , 1 ) ctrA = 'n' else k = size ( A , 1 ) m = size ( A , 2 ) if ( present ( cjA ) . and . cjA ) then ctrA = 'c' else ctrA = 't' end if end if if (. not . trB ) then kb = size ( B , 1 ) n = size ( B , 2 ) ctrB = 'n' else kb = size ( B , 2 ) n = size ( B , 1 ) if ( present ( cjB ) . and . cjB ) then ctrB = 'c' else ctrB = 't' end if end if call zgemm ( ctrA , ctrB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), C , m ) end function array_times_array pure function array_times_array_simple ( A , B ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ) :: C ( size ( A , 1 ), size ( B , 2 )) C = array_times_array ( A , B , . false ., . false .) end function array_times_array_simple function array_power ( A , n ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer , intent ( in ) :: n complex ( 8 ) :: B ( size ( A , 1 ), size ( A , 1 )) complex ( 8 ) :: C ( size ( A , 1 ), size ( A , 1 )) integer :: ii if ( n > 0 ) then B = A do ii = 2 , n B = B . m . A end do C = B elseif ( n == 0 ) then C = array_eye ( size ( A , dim = 1 )) elseif ( n == - 1 ) then C = array_inverse ( A ) else C = array_inverse ( A ) B = C do ii = 2 , - n B = B . m . C end do C = B end if end function array_power pure function array_transpose ( A , t ) result ( C ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) character , intent ( in ) :: t complex ( 8 ) :: C ( size ( A , 2 ), size ( A , 1 )) if (( t == 't' ) . or . ( t == 'T' )) then C = Transpose ( A ) elseif (( t == 'c' ) . or . ( t == 'C' )) then C = Transpose ( Conjg ( A )) end if end function array_transpose function array_eigen ( A , B , eigvec , itype , uplo ) result ( eig ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ), intent ( in ), optional :: B (:, :) real ( 8 ) :: eig ( size ( A , 1 )) complex ( 8 ), intent ( inout ), optional :: eigvec ( size ( A , 1 ), size ( A , 2 )) integer , intent ( in ), optional :: itype CHARACTER , intent ( in ), optional :: uplo integer :: LDA , N , LDB , lwork , INFO , itypeop CHARACTER :: jobz , uploop real ( 8 ) :: RWORK ( 3 * size ( A , 2 )) complex ( 8 ) :: work ( 1 + 4 * size ( A , 2 ) + size ( A , 2 ) ** 2 ), C ( size ( A , 1 ), size ( A , 2 )) C (:, :) = A (:, :) if ( present ( eigvec )) then jobz = 'V' else jobz = 'N' end if uploop = merge ( uplo , 'U' , present ( uplo )) itypeop = merge ( itype , 1 , present ( itype )) N = size ( A , dim = 2 ) LDA = size ( A , dim = 1 ) LWORK = size ( WORK ) if ( present ( B )) then LDB = size ( B , dim = 1 ) call zhegv ( itypeop , jobz , uploop , N , C , LDA , B , LDB , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEGV fails with INFO=' , INFO call abort () end if else LDB = LDA call zheev ( jobz , uploop , N , C , LDA , eig , WORK , LWORK , RWORK , INFO ) if ( INFO . ne . 0 ) then print * , '@array_eigen ZHEEV fails with INFO=' , INFO call abort () end if end if if ( present ( eigvec )) eigvec = C end function array_eigen pure function array_to_diag ( A ) result ( diag ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: diag ( size ( A , 1 )) integer :: ii do concurrent ( ii = 1 : size ( A , 1 )) diag ( ii ) = A ( ii , ii ) end do end function array_to_diag function array_inverse2 ( A , UPLO ) ! for Hermitian matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: array_inverse2 ( size ( A , dim = 1 ), size ( A , dim = 1 )) CHARACTER , intent ( in ) :: UPLO integer :: info , lda , lwork , n , nnz integer :: ipiv ( size ( A , 1 )) complex ( 8 ), allocatable :: work (:, :) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse2 (:, :) = A (:, :) allocate ( work ( n * n , n * n )) LDA = size ( A , 2 ) call zhetrf ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , size ( WORK ), info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRF fails with INFO=' , info call abort () end if call zhetri ( UPLO , n , array_inverse2 , LDA , ipiv , WORK , info ) if ( info . ne . 0 ) then print * , '@array_inverse2 ZHETRI fails with INFO=' , info call abort () end if end function array_inverse2 function array_inverse ( A ) ! for General matrix implicit none complex ( 8 ), intent ( in ) :: A (:, :) integer :: info , n integer :: ipiv ( size ( A , 1 )) complex ( 8 ), dimension ( size ( A , dim = 1 ), size ( A , dim = 1 )) :: array_inverse complex ( 8 ), allocatable :: work (:, :) n = size ( A , 1 ) if ( n /= size ( A , 2 )) then print * , '@array_inverse, size not square' , n , size ( A , 2 ) call abort () end if array_inverse (:, :) = A (:, :) allocate ( work ( n * n , n * n )) call zgetrf ( n , n , array_inverse , n , ipiv , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRF fails with INFO=' , info call abort () end if call zgetri ( n , array_inverse , n , ipiv , work , n * n , info ) if ( info . ne . 0 ) then print * , '@array_inverse ZGETRI fails with INFO=' , info call abort () end if end function array_inverse pure function array_trace ( A ) result ( tr ) implicit none complex ( 8 ), intent ( in ) :: A (:, :) complex ( 8 ) :: tr integer :: ii tr = sum (( / ( A ( ii , ii ), ii = 1 , size ( A , 1 )) / )) end function array_trace elemental function matrix_trace ( M ) result ( tr ) implicit none type ( type_matrix_complex ), intent ( in ) :: M complex ( 8 ) :: tr integer :: ii tr = sum (( / ( M % m ( ii , ii ), ii = 1 , M % size ( 1 )) / )) end function matrix_trace subroutine matrix_copy ( matrices , tab ) implicit none type ( type_matrix_complex ), intent ( in ) :: matrices (:) complex ( 8 ), intent ( out ) :: tab (:, :, :) integer :: i do concurrent ( i = 1 : size ( matrices )) tab ( 1 : matrices ( i )% size ( 1 ), 1 : matrices ( i )% size ( 2 ), i ) = matrices ( i )% m (:, :) end do end subroutine matrix_copy subroutine triMUL_C ( A , B , C , R , trA , trB , trC ) complex ( 8 ), intent ( in ), dimension (:, :) :: A , B , C complex ( 8 ), intent ( inout ), allocatable :: R (:, :) character , intent ( in ) :: trA , trB , trC complex ( 8 ), allocatable , dimension (:, :) :: tmp integer :: n , m , k , kb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in triMUL_C! trB is wrong: \" , trB call abort () end if if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in triMUL_C! Matrix dimension is wrong\" , k , kb call abort () end if call MUL_C ( A , B , trA , trB , tmp ) call MUL_C ( tmp , C , 'n' , trC , R ) deallocate ( tmp ) end subroutine triMUL_C subroutine MUL_C ( A , B , trA , trB , R ) complex ( 8 ), intent ( in ) :: A (:, :), B (:, :) complex ( 8 ), intent ( inout ), allocatable :: R (:, :) CHARACTER , intent ( in ) :: trA , trB integer :: n , m , k , kb , lda , ldb if (( trA . ne . 'n' ) . and . ( trA . ne . 'N' ) . and . ( trA . ne . 't' ) . and . ( trA . ne . 'T' ) & . and . ( trA . ne . 'c' ) . and . ( trA . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trA is wrong: \" , trA call abort () end if if (( trB . ne . 'n' ) . and . ( trB . ne . 'N' ) . and . ( trB . ne . 't' ) . and . ( trB . ne . 'T' ) & . and . ( trB . ne . 'c' ) . and . ( trB . ne . 'C' )) then write ( * , * ) \"ERROR in MUL_C! trB is wrong: \" , trB call abort () end if lda = size ( A , 1 ) ldb = size ( B , 1 ) if (( trA . eq . 'n' ) . or . ( trA . eq . 'N' )) then k = size ( A , 2 ) m = size ( A , 1 ) else k = size ( A , 1 ) m = size ( A , 2 ) end if if (( trB . eq . 'n' ) . or . ( trB . eq . 'N' )) then kb = size ( B , 1 ) n = size ( B , 2 ) else kb = size ( B , 2 ) n = size ( B , 1 ) end if if ( k . ne . kb ) then write ( * , * ) \"ERROR in MUL_C! Matrix dimension is wrong\" , k , kb call abort () end if if ( allocated ( R )) then if (( size ( R , 1 ) . ne . m ) . or . ( size ( R , 2 ) . ne . n )) then deallocate ( R ) Allocate ( R ( m , n )) end if else Allocate ( R ( m , n )) end if R = dcmplx ( 0.0d0 , 0.0d0 ) call zgemm ( trA , trB , m , n , k , dcmplx ( 1.0d0 , 0.0d0 ), A , lda , B , ldb , dcmplx ( 0.0d0 , 0.0d0 ), R , m ) end subroutine MUL_C end module matrix_c","tags":"","loc":"sourcefile/matrix_c.f90.html"},{"title":"selfenergy_mod.f90 – Quantum transport simulator","text":"Contents Source Code selfenergy_mod.f90 Source Code","tags":"","loc":"sourcefile/selfenergy_mod.f90.html"}]}